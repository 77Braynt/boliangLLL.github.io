{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"John Doe","url":"https://bolianglll.github.io"},"pages":[],"posts":[{"title":"Vue.js个人经验总结","slug":"Vue.js个人总结","date":"2018-12-11T08:13:05.771Z","updated":"2018-12-11T08:18:51.409Z","comments":true,"path":"2018/12/11/Vue.js个人总结/","link":"","permalink":"https://bolianglll.github.io/2018/12/11/Vue.js个人总结/","excerpt":"","text":"其实Vue里，在我们开发中，大多数的东西我们都可以在vue.js的官网里找到。但是也有些 在你封指令或者组件时候。有更便捷的方法，或者可以用高级用法来形容。 自定义指令 除了核心功能默认内置的指令 (v-model 和 v-show)，Vue 也允许注册自定义指令。注意，在 Vue2.0 中，代码复用和抽象的主要形式是组件。然而，有的情况下，你仍然需要对普通 DOM 元素进行底层操作，这时候就会用到自定义指令。举个聚焦输入框的例子当页面加载时，该元素将获得焦点 (注意：autofocus 在移动版 Safari 上不工作)。事实上，只要你在打开这个页面后还没点击过任何内容，这个输入框就应当还是处于聚焦状态。现在让我们用指令来实现这个功能12345678// 注册一个全局自定义指令 `v-focus`Vue.directive(&apos;focus&apos;, &#123; // 当被绑定的元素插入到 DOM 中时…… inserted: function (el) &#123; // 聚焦元素 el.focus() &#125;&#125;) 如果想注册局部指令，组件中也接受一个 directives 的选项：12345678directives: &#123; focus: &#123; // 指令的定义 inserted: function (el) &#123; el.focus() &#125; &#125;&#125; 使用 然后你可以在模板中任何元素上使用新的 v-focus 属性，如下：1&lt;input v-focus&gt; 例如 VUX里面也提供了 TransferDom 的自定义指令。 render","categories":[],"tags":[]},{"title":"亮眼操作：关于vux的v-transfer-dom的指令","slug":"亮眼操作：关于vux的v-transfer-dom的指令","date":"2018-12-06T02:19:41.000Z","updated":"2018-12-07T09:22:13.150Z","comments":true,"path":"2018/12/06/亮眼操作：关于vux的v-transfer-dom的指令/","link":"","permalink":"https://bolianglll.github.io/2018/12/06/亮眼操作：关于vux的v-transfer-dom的指令/","excerpt":"","text":"在我自己的移动端项目实战项目中， 我在封装组件的时候，偶尔会弹出很多框，列如还有一些遮罩搭配弹窗的东西。 往往，我们为了复用性更高。 我们会封装成组件。问题来了， 我们要怎么定位到body的宽度，而去无视父组件的宽度和高度呢？ 这个时候，vux的v-transfer-dom指令， 就会让我们更容易的去封装这些弹框组。让代码更加简单 在我们开发的过程中，我们用到了Vux,而且遇到 Alert Popup XDialog等组件，我们可以用v-transfer-dom实现移动到body下。 必须有一个 div 作为占位元素否则会出错 1使用 注册局部指令1234567import &#123; TransferDom &#125; from &apos;vux&apos;export default &#123; directives: &#123; TransferDom &#125;&#125; 上面注意是在Vue 中的directives中引用这个指令 模板使用123&lt;div v-transfer-dom&gt; &lt;popup v-model=&quot;show&quot;&gt;&lt;/popup&gt;&lt;div&gt; 如果有博友想了解更多的关于移动端的布局。 现阶段的移动端的布局。 CSS可以去学习一下flex布局。 很适合现阶段的移动端布局","categories":[],"tags":[]},{"title":"在公司项目和自己实战项目的GIT干货操作","slug":"在公司项目和自己实战项目的GIT干货操作","date":"2018-12-06T02:19:41.000Z","updated":"2018-12-10T08:42:17.272Z","comments":true,"path":"2018/12/06/在公司项目和自己实战项目的GIT干货操作/","link":"","permalink":"https://bolianglll.github.io/2018/12/06/在公司项目和自己实战项目的GIT干货操作/","excerpt":"","text":"本博主会在以后的日子里 慢慢的分享出我遇到的困难~ 请期待~由于示范连接码云的图片有点多。 本博主也太会弄。 所以有关连接码云的操作，可以上网查。 这个主要讲GIT操作 我在网上看了下，也有其它比较好的GIT操作。 例如https://blog.csdn.net/youzhouliu/article/details/78952453这个博主的，写的也比较详细。下面写的是本人的经验。 如果还有其它难题，可以看看这个博主的处理 git创建版本库—公司的项目是用gitlab仓库的。 本人的项目是用码云保存代码的。 下面的介绍用码云上的操作来介绍外部连接提供：https://blog.csdn.net/gusy5188/article/details/80360096 连接码云 补充一下。里面没有介绍.ssh-rsa在哪，不用GIT去查的话，可以直接在露肩路径 这个文件在C:\\Users\\Administrator.ssh 中的id_rsa.pub文件里面。 可以复制内容在码云的SSH公钥中。 就是连接成功了。 接下来就是配置其它基本信息 GIT 的基本操作1 创建数据库12Git init //在一个文件目录执行该指令，会把该目录快速设置成Git的代码仓库。Git clone //从远程服务器clone工程，也会创建一个代码仓库。 2 提交修改git status 查看当前仓库状态。会提示那些文件发生修改，哪些内容需要add&amp;commit。git add . 把本地修改的文件，加入到本地的缓存区 （这里代表的是全部修改文件）git add 文件名 添加单个文件git commit -m “这次添加文件的注释” 将add的文件添加注释并且提交到代码仓库git push origin master(分支) 在git Bash 中修改远程的仓库地址在我的开发项目中， 会每过几个迭代，就会更新远程的用户名。要我们用这个新的用户名去管理git Lab上的代码。所以有时候系统不自动更新git bash上的远程账号的话，会无法拉取和提交。所以要修改远程的用户名。还有对于一些项目会迁移， 作为git仓库的服务器IP地址变了。 本地代码挺多，重新检出太占时间，可以修改一个什么配置让我本地仓库和新的远程仓库下面是解决方法： 方法一通过命令直接修改远程地址1进入你们项目目录2git remote 查看所有远程仓库， git remote xxx 查看指定远程仓库地址3git remote set-url origin http://xxxxxx/xxxxx.git 然后当你git pull yourorigin branch 的时候 他就会让你重新输入你在gitlab(github)上的user.name和password。 方法二 通过命令先删除再添加远程仓库1.进入你们项目目录git remote 查看所有远程仓库， git remote xxxx 查看指定远程仓库地址git remote rm origingit remote add origin http://xxxxxx/xxxxx.git 方法三 通过第三方git客户端修改。以SourceTree为例，点击 仓库 -&gt; 仓库配置 -&gt; 远程仓库 即可管理此项目中配置的所有远程仓库， 而且这个界面最下方还可以点击编辑配置文件。可以实现远程仓库的更换。","categories":[],"tags":[]},{"title":"关于CSS3中的 box-sizing border-box;","slug":"CSS3中的'' box-sizing border-box;'微妙之处","date":"2018-12-05T04:00:00.000Z","updated":"2018-12-05T09:29:14.481Z","comments":true,"path":"2018/12/05/CSS3中的'' box-sizing border-box;'微妙之处/","link":"","permalink":"https://bolianglll.github.io/2018/12/05/CSS3中的'' box-sizing border-box;'微妙之处/","excerpt":"","text":"在最近我在做自己的项目的过程之中， 在CSS中。我遇到了 box-sizing border-box;我通过用这个 box-sizing border-box;，简化了不少代码。 所以想在这通过网上的一些文章，和自己的一些理解来介绍一下 content-box指定元素的宽度和高度（最小/最大属性）适用于box的宽度和高度。元素的填充和边框布局和绘制指定宽度和高度除外 border-box指定宽度和高度（最小/最大属性）确定元素边框box。也就是说，对元素指定宽度和高度包括padding和border的指定。内容的宽度和高度减去各自双方该边框和填充的宽度从指定的”宽度”和”高度”属性计算 inherit指定box-sizing属性的值，应该从父元素继承 对于boder-box的计算方法border-box width 和 height 属性包括内容，内边距和边框，但不包括外边距。这是当文档处于 Quirks模式 时Internet Explorer使用的盒模型。注意，填充和边框将在盒子内 , 例如, .box {width: 350px; border: 10px solid black;} 导致在浏览器中呈现的宽度为350px的盒子。内容框不能为负，并且被分配到0，使得不可能使用border-box使元素消失。这里的维度计算为： width = border + padding + 内容的 width， height = border + padding + 内容的 height。 总结一般写页面对ui设计好的来说，我们最好使用这个属性，这样对整体布局很有好处，不然，页面很容易出现问题。 便于朋友记忆。 加多一个overflow:hidden的用法在此文章 overflow:hidden的作用是1.隐藏溢出的东西 #wai{ width:200px; background:#000; height:200px; border:2px blue solid; } #nei { float:left; width:300px; height:300px; background:red;} 当我们没有给wai这个div设置高度的时候，nei这个div的高度，就会撑开wai这个div，而在另一个方面，我们要注意到的是，当我们给wai这个div加上一个高度值，那么无论nei这个div的高度是多少，wai这个高度都是我们设定的值。而当nei的高度超过wai的高度的时候，超出的部分就会被隐藏。这就是隐藏溢出的含义!2.清楚浮动当nei这个div加上浮动这个属性的时候，在显示器的侧面，它已经脱离了wai这个div，也就是说，此时的nei的宽高是多少， 对于已经脱离了的wai来说，都是不起作用的。当我们全面的理解了浮动这个词的含义的时候，我们就理解overflow:hidden这个属性中的解释，清除浮动是什么意思了。也就是说，当我们给wai这个div加上overflow:hidden这个属性的时候，其中的nei等等带浮动属性的div的在这个立体的浮动已经被清除了。","categories":[],"tags":[]},{"title":"Flex布局-一个前端工程师必不可缺的布局","slug":"Flex布局-一个前端工程师必不可缺的布局","date":"2018-12-05T02:19:41.000Z","updated":"2018-12-10T08:57:33.237Z","comments":true,"path":"2018/12/05/Flex布局-一个前端工程师必不可缺的布局/","link":"","permalink":"https://bolianglll.github.io/2018/12/05/Flex布局-一个前端工程师必不可缺的布局/","excerpt":"","text":"最近项目中， 由于前端页面布局是页面小组做的。 我的小组的人忘记如何去布局了。在此想介绍一下FLEX布局给你们认识。作为web端和移动端的前流布局 Flex布局 参考阮一峰的文章flex布局 语法：http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html 实战：http://www.ruanyifeng.com/blog/2015/07/flex-examples.html 里面该有的都会有。 在下面 我讲解一下比较常用，然后到概念 flex:1; 让所有弹性盒模型对象的子元素都有相同的长度，忽略它们内部的内容","categories":[],"tags":[]},{"title":"关于eventloop事件循环机制和aysnc和await的解决异步方法的详解","slug":"关于eventloop事件监听机制和aysnc和await的解决异步方法的详解","date":"2018-12-04T02:19:41.000Z","updated":"2018-12-05T03:36:06.566Z","comments":true,"path":"2018/12/04/关于eventloop事件监听机制和aysnc和await的解决异步方法的详解/","link":"","permalink":"https://bolianglll.github.io/2018/12/04/关于eventloop事件监听机制和aysnc和await的解决异步方法的详解/","excerpt":"","text":"此文章是我在朋友推荐给我看的文章，然后我自己想总结一下关于eventloop事件和aysnc和await的事件解决顺序（不讲解其中原理。讲顺序）。如果我讲解的有问题。 麻烦发我邮箱，嘻嘻嘻。 很高兴大家帮我指出错误。 此文章是参考下面两个博客文章的解释。 如果我讲解的不清楚，你们可以去该文章了解一下,我觉的他们解释的挺清楚和挺好的。https://www.cnblogs.com/hanzhecheng/p/9046144.html eventloophttps://juejin.im/post/5c0397186fb9a049b5068e54 async eventloop事件循环机制JavaScript的事件分两种，宏任务(macro-task)和微任务(micro-task) 宏任务：包括整体代码script，setTimeout，setInterval微任务：Promise.then(非new Promise)，process.nextTick(node中) 事件的执行顺序，是先执行宏任务，然后执行微任务，这个是基础，任务可以有同步任务和异步任务，同步的进入主线程，异步的进入Event Table并注册函数，异步事件完成后，会将回调函数放入Event Queue中(宏任务和微任务是不同的Event Queue)，同步任务执行完成后，会从Event Queue中读取事件放入主线程执行，回调函数中可能还会包含不同的任务，因此会循环执行上述操作。 JS是单线程语言也就是说，JS一次只能做一件事情。cpu处理指令速度非常快，远比磁盘I/O和网络I/O速度快，所以一些cpu直接执行的任务就成了优先执行主线任务（即同步任务synchronous），然后需要io返回数据的任务就成了等待被执行的任务（即异步任务asynchronous）同步任务：在主线程上排队执行的任务，前一个任务执行完毕，才能执行后一个任务；异步任务：不进入主线程、而进入”任务队列”（task queue）的任务，只有”任务队列”通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。 代码解析12345678910111213141516171819console.log('1');setTimeout(function() &#123; console.log('2'); process.nextTick(function() &#123; console.log('3'); &#125;) new Promise(function(resolve) &#123; console.log('4'); resolve(); &#125;).then(function() &#123; console.log('5') &#125;)&#125;)输出：12435 宏任务同步代码console.log(‘1’),不多说setTimeout，加入宏任务Event Queue，没有发现微任务，第一轮事件循环走完第二轮事件循环开始，先执行宏任务，从宏任务Event Queue中独取出setTimeout的回调函数同步代码console.log(‘2’),发现process.nextTick，加入微任务Event Queuenew Promise，同步执行console.log(‘4’),发现then，加入微任务Event Queue宏任务执行完毕，接下来执行微任务，先执行process.nextTick，然后执行Promise.then微任务执行完毕，第二轮事件循环走完，没有发现宏任务，事件循环结束 总结:1.事件循环，先执行宏任务，其中同步任务立即执行，异步任务，加载到对应的的Event Queue中(setTimeout等加入宏任务的Event Queue，Promise.then加入微任务的Event Queue)，2.所有同步宏任务执行完毕后，如果发现微任务的Event Queue中有未执行的任务，会先执行其中的任务，这样算是完成了一次事件循环。3.接下来查看宏任务的Event Queue中是否有未执行的任务，有的话，就开始第二轮事件循环，依此类推。记得上面的宏任务和微任务的分类。这个就是JS的eventloop的循环时间机制 ES6async和await的解决异步函数方法-事件顺序1.async介绍 async function 用于声明 一个 返回 AsyncFunction 对象的异步函数。异步函数是值通过事件循环异步执行的函数，它会通过一个隐式的 Promise 返回其结果。如果你的代码使用了异步函数，它的语法和结构更像是标准的同步函数也就是说每一个async都会返回来一个隐式的 Promise .如果还想了解更多关于async的内容，可以去上面分享的那个博主的网站去看。 我在下面想分析关于async的事件顺序机制。下面的解释不代表博主的说法错误。本人只是想通过eventloop的解释，去解释下面的顺序 async Promise setTimeout(定时器) 的结合使用情况求下面输出结果1234567891011121314151617181920async function async1()&#123; console.log('async1 start') await async2() console.log('async1 end')&#125;async function async2()&#123; console.log('async2')&#125;console.log('script start')setTimeout(function()&#123; console.log('setTimeout')&#125;,0) async1();new Promise(function(resolve)&#123; console.log('promise1') resolve();&#125;).then(function()&#123; console.log('promise2')&#125;)console.log('script end') 正确的答案是：script startasync1 startasync2promise1script endpromise2async1 endsetTimeou 非常重要的一句是：遇到 await 表达式时，会让 async 函数 暂停执行，等到 await 后面的语句（Promise）状态发生改变（resolved或者rejected）之后，再恢复 async 函数的执行（再之后 await 下面的语句），并返回解析值（Promise的值） 解释上面的顺序：1.执行同步任务-console.log(‘script start’) /12.遇到了宏任务，且为异步的setTimeout。 把次函数加入到宏任务的Event Queue3.执行async1（）里面的同步代码 console.log(‘async1 start’)/24.执行 async2()里面的同步代码 console.log(‘async2’) /3（但是async2函数是给async定义的一个函数。 他会返回来一个隐式的promise对象,而且也会跳出上面的async1函数）4.执行promise的同步代码 console.log(‘promise1’)/4。 遇到了promise().resolve(). 返回来了一个promise对象，。5.执行同步console.log(‘script end’)/5。第一轮事件走完第二轮时间开始6执行async2()中的promise()。要等待reslove()。 把他压进队列（）。7执行.then后面的函数 console.log(‘promise2’)/6.第三轮开始等待完async2的promise()之后。 执行 console.log(‘async1 end’) 可能大家还没多理解。 我一开始也是。 然后我测试多了几次后列如 1234567891011121314151617181920async function async1()&#123; console.log('async1 start') await async2() console.log('async1 end')&#125; function async2()&#123; console.log('async2')&#125;console.log('script start')setTimeout(function()&#123; console.log('setTimeout')&#125;,0) async1();new Promise(function(resolve)&#123; console.log('promise1') resolve();&#125;).then(function()&#123; console.log('promise2')&#125;)console.log('script end') 正确的答案是：script startasync1 startasync2promise1script endasync1 endpromise2setTimeou 解释上面的顺序：第一轮事件和上面的类似。 但是没有async2()没有给async封装。 不会返回来一个promose()对象。所以第二轮有问题第一轮事件走完第二轮时间开始6.执行 console.log(‘async1 end’)7执行.then后面的函数 console.log(‘promise2’)上面的顺序就会有变化了。 总结一下：除此之外。我在一些评论下看到： 宏任务的优先级，是高于微任务的啊，settimeout 是去了下一个event loop。而且我们可以把await后面的代码。都当promise.then（微任务），这样就非常的好理解了—其实看到这， 我就更清楚上面的顺序了。。 哈哈 ，–新手理解。 当压进队列后，会从一开始再运行一下。 其实上面我讲的可能有点混乱。 但是这可能是我自己一开始比较好理解的方法。然后一步一步看到别人的想法，才更容易理解。 如果讲的不够清楚。可以去上面的那些博客主里面看一看。欢迎大家给我意见。","categories":[],"tags":[]},{"title":"成长的点点滴滴基础","slug":"成长的点点滴滴基础","date":"2018-12-04T02:19:41.000Z","updated":"2018-12-11T07:44:16.107Z","comments":true,"path":"2018/12/04/成长的点点滴滴基础/","link":"","permalink":"https://bolianglll.github.io/2018/12/04/成长的点点滴滴基础/","excerpt":"","text":"get和Post区别数据传输：get post的区别重点：GET把参数包含在URL中（数据比较少），POST通过request body传递参数。get的话 就是能获取数据， 但是不能保存。 就是表单那些不能保存Post的话 可以获取数据也能保存。 另外：GET请求在URL中传送的参数是有长度限制的，而POST么有。GET请求只能进行url编码，而POST支持多种编码方式 判断一个变量类型是数组还是对象1.通过length属性：一般情况下对象没有length属性值，其值为undefiend，而数组的length值为number类型 缺点：非常不实用，当对象的属性存在length，且其值为number（比如类数组），则该方法失效，不建议使用，看看即可。2.通过instanceof来判断区分12345678var arr = [1, 2, 3]; var obj = &#123; name: &apos;lyl&apos;, age: 18, 1: &apos;name&apos; &#125; console.log(arr instanceof Array); //true console.log(obj instanceof Array); //false 3.通过constructor12345678var arr = [1, 2, 3]; var obj = &#123; name: &apos;lyl&apos;, age: 18, 1: &apos;name&apos; &#125; console.log(arr.constructor === Array); //true console.log(obj.constructor === Array); //false 通过toString()方法，数组原型和对象原型定义的toString()方法不同-可以判断任何类型12345678 var arr = [1, 2, 3];var obj = &#123; name: &apos;lyl&apos;, age: 18, 1: &apos;name&apos;&#125;console.log(Object.prototype.toString.call(arr) === &apos;[object Array]&apos;); //trueconsole.log(Object.prototype.toString.call(boj) === &apos;[object Array]&apos;); //false 5.随便找一个数组仅有的方法，来判断数组和对象谁有该方法即可（样例以sort来举例）123456789 var arr = [1, 2, 3];var obj = &#123; name: &apos;lyl&apos;, age: 18, 1: &apos;name&apos;&#125; console.log(arr.sort === Array.prototype.sort); //trueconsole.log(obj.sort === Array.prototype.sort); //false 总结：方法应用权重： 优先使用方四toString，因为该方法几乎无缺陷。 次之可以使用方二instanceof和方三constructor 剩下的方法玩玩即可，不实用 js === 和==的区别== 用于比较 判断 两者相等 ==在比较的时候可以转自动换数据类型===用于严格比较 判断两者严格相等 ===严格比较，不会进行自动转换 总之： “==” 只要求值相等; “===” 要求值和类型都相等","categories":[],"tags":[]},{"title":"“实战项目用到的技术总结”","slug":"“实战项目技术总结”","date":"2018-12-04T02:19:41.000Z","updated":"2018-12-11T07:29:11.401Z","comments":true,"path":"2018/12/04/“实战项目技术总结”/","link":"","permalink":"https://bolianglll.github.io/2018/12/04/“实战项目技术总结”/","excerpt":"","text":"大概先总结一下后面会总结。请等待 公司项目XX（不透露）1.上了生产之后， 如何做到版本控制。 —-JSAPI上控制","categories":[],"tags":[]},{"title":"前端学习资料","slug":"前端学习资料","date":"2018-12-03T09:00:16.296Z","updated":"2018-12-11T09:19:14.660Z","comments":true,"path":"2018/12/03/前端学习资料/","link":"","permalink":"https://bolianglll.github.io/2018/12/03/前端学习资料/","excerpt":"","text":"作为一个前端攻城狮必须掌握的技能ES6阮一峰的ES6 是我觉的比较容易让人易懂和比较完善的教程。 http://es6.ruanyifeng.com/#docs/destructuring 代码规范化文章教程JSOC的规范化，是每一个攻城狮代码规范的标准。 值得学习 https://www.css88.com/doc/jsdoc/ HTTP跨域介绍-掘金的一篇好文推荐https://juejin.im/post/5a2f92c65188253e2470f16d#heading-5 前端面试题总结这是一个网上的团队总结的所有面试题。 我觉得这个文章不仅对我们面试有作用， 而且对于我们基础知识的提升也起很多作用。 值得我们去看看 https://yuchengkai.cn/docs/zh/frontend/ 个人学习介绍本人是主攻Web端的Vue攻城狮，我会在以后的日子里。慢慢的把我在实际项目中遇到的知识难点和亮点分享给各位热爱前端的同学。 哈哈哈， 我只是一个新手上路的菜鸟，如果看到我分享的只是有问题的话，很乐意你们去联系我。邮箱 - - - boliangleung@163.com希望我以后的东西能帮到大家","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2018-11-27T02:04:45.726Z","updated":"2018-12-03T08:12:49.829Z","comments":true,"path":"2018/11/27/hello-world/","link":"","permalink":"https://bolianglll.github.io/2018/11/27/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}