{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"John Doe","url":"https://bolianglll.github.io"},"pages":[],"posts":[{"title":"为什么要前后端分离？各有什么优缺点？","slug":"为什么要前后端分离？各有什么优缺点？","date":"2018-12-27T07:09:21.703Z","updated":"2018-12-27T07:13:26.132Z","comments":true,"path":"2018/12/27/为什么要前后端分离？各有什么优缺点？/","link":"","permalink":"https://bolianglll.github.io/2018/12/27/为什么要前后端分离？各有什么优缺点？/","excerpt":"前后分离就是在 架构层次 上 构建项目或对现有的项目 客户端 服务端 分离开，减少前后端代码的耦合度。","text":"前后分离就是在 架构层次 上 构建项目或对现有的项目 客户端 服务端 分离开，减少前后端代码的耦合度。 一、前端前后端分离已成为互联网项目开发的业界标准使用方式，通过nginx+tomcat的方式（也可以中间加一个nodejs）有效的进行解耦，并且前后端分离会为以后的大型分布式架构、弹性计算架构、微服务架构、多端化服务（多种客户端，例如：浏览器，车载终端，安卓，IOS等等）打下坚实的基础。这个步骤是系统架构从猿进化成人的必经之路。 核心思想是前端html页面通过ajax调用后端的restuful api接口并使用json数据进行交互。 在互联网架构中，名词解释： Web服务器：一般指像nginx，apache这类的服务器，他们一般只能解析静态资源。 应用服务器：一般指像tomcat，jetty，resin这类的服务器可以解析动态资源也可以解析静态资源，但解析静态资源的能力没有web服务器好。 一般都是只有web服务器才能被外网访问，应用服务器只能内网访问。 二、术业有专攻（开发人员分离）1、对于后端java工程师： 把精力放在java基础，设计模式，jvm原理，spring+springmvc原理及源码，linux，mysql事务隔离与锁机制，mongodb，http/tcp，多线程，分布式架构，弹性计算架构，微服务架构，java性能优化，以及相关的项目管理等等。 后端追求的是：三高（高并发，高可用，高性能），安全，存储，业务等等。 2、对于前端工程师： 把精力放在html5，css3，jquery，angularjs，bootstrap，reactjs，vuejs，webpack，less/sass，gulp，nodejs，Google V8引擎，javascript多线程，模块化，面向切面编程，设计模式，浏览器兼容性，性能优化等等。 前端追求的是：页面表现，速度流畅，兼容性，用户体验等等。 术业有专攻，这样你的核心竞争力才会越来越高，正所谓你往生活中投入什么，生活就会反馈给你什么。并且两端的发展都越来越高深，你想什么都会，那你毕竟什么都不精。 通过将team分成前后端team，让两边的工程师更加专注各自的领域，独立治理，然后构建出一个全栈式的精益求精的team。 三、原始人时代（各种耦合）几曾何时，我们的JavaWeb项目都是使用了若干后台框架，springmvc/struts + spring + spring jdbc/hibernate/mybatis 等等。 大多数项目在java后端都是分了三层，控制层，业务层，持久层。控制层负责接收参数，调用相关业务层，封装数据，以及路由&amp;渲染到jsp页面。然后jsp页面上使用各种标签或者手写java表达式将后台的数据展现出来，玩的是MVC那套思路。 我们先看这种情况：需求定完了，代码写完了，测试测完了，然后呢？要发布了吧？你需要用maven或者eclipse等工具把你的代码打成一个war包，然后把这个war包发布到你的生产环境下的web容器里，对吧？ 发布完了之后，你要启动你的web容器，开始提供服务，这时候你通过配置域名，dns等等相关，你的网站就可以访问了（假设你是个网站）。那我们来看，你的前后端代码是不是全都在那个war包里？包括你的js，css，图片，各种第三方的库，对吧？ 好，下面在浏览器中输入你的网站域名（www.xxx.com），之后发生了什么？（这个问题也是很多公司的面试题）我捡干的说了啊，基础不好的童鞋请自己去搜。 浏览器在通过域名通过dns服务器找到你的服务器外网ip,将http请求发送到你的服务器，在tcp3次握手之后（http下面是tcp/ip），通过tcp协议开始传输数据，你的服务器得到请求后，开始提供服务，接收参数，之后返回你的应答给浏览器，浏览器再通过content-type来解析你返回的内容，呈现给用户。 那么我们来看，我们先假设你的首页中有100张图片，此时，用户的看似一次http请求，其实并不是一次，用户在第一次访问的时候，浏览器中不会有缓存，你的100张图片，浏览器要连着请求100次http请求（有人会跟我说http长连短连的问题，不在这里讨论），你的服务器接收这些请求，都需要耗费内存去创建socket来玩tcp传输（消耗你服务器上的计算资源）。 重点来了，这样的话，你的服务器的压力会非常大，因为页面中的所有请求都是只请求到你这台服务器上，如果1个人还好，如果10000个人并发访问呢（先不聊服务器集群，这里就说是单实例服务器），那你的服务器能扛住多少个tcp连接？你的带宽有多大？你的服务器的内存有多大？你的硬盘是高性能的吗？你能抗住多少IO？你给web服务器分的内存有多大？会不会宕机？ 这就是为什么，越是大中型的web应用，他们越是要解耦。理论上你可以把你的数据库+应用服务+消息队列+缓存+用户上传的文件+日志+等等都扔在一台服务器上，你也不用玩什么服务治理，也不用做什么性能监控，什么报警机制等等，就乱成一锅粥好了。但是这样就好像是你把鸡蛋都放在一个篮子里，隐患非常大。如果因为一个子应用的内存不稳定导致整个服务器内存溢出而hung住，那你的整个网站就挂掉了。 如果出意外挂掉，而恰好这时你们的业务又处于井喷式发展高峰期，那么恭喜你，业务成功被技术卡住，很可能会流失大量用户，后果不堪设想。（注意：技术一定是要走在业务前面的，否则你将错过最佳的发展期哟，亲~） 此外，你的应用全部都耦合在一起，相当于一个巨石，当服务端负载能力不足时，一般会使用负载均衡的方式，将服务器做成集群，这样其实你是在水平扩展一块块巨石，性能加速度会越来越低，要知道，本身负载就低的功能or模块是没有必要水平扩展的，在本文中的例子就是你的性能瓶颈不在前端，那干嘛要水平扩展前端呢？？？还有发版部署上线的时候，我明明只改了后端的代码，为什么要前端也跟着发布呢？？？ 正常的互联网架构，是都要拆开的，你的web服务器集群，你的应用服务器集群+文件服务器集群+数据库服务器集群+消息队列集群+缓存集群等等。 四、JSP的痛点以前的javaWeb项目大多数使用jsp作为页面层展示数据给用户，因为流量不高，因此也没有那么苛刻的性能要求，但现在是大数据时代，对于互联网项目的性能要求是越来越高，因此原始的前后端耦合在一起的架构模式已经逐渐不能满足我们，因此我们需要需找一种解耦的方式，来大幅度提升我们的负载能力。 1、动态资源和静态资源全部耦合在一起，服务器压力大，因为服务器会收到各种http请求，例如css的http请求，js的，图片的等等。一旦服务器出现状况，前后台一起玩完，用户体验极差。 2、UI出好设计图后，前端工程师只负责将设计图切成html，需要由java工程师来将html套成jsp页面，出错率较高（因为页面中经常会出现大量的js代码），修改问题时需要双方协同开发，效率低下。 3、jsp必须要在支持java的web服务器里运行（例如tomcat，jetty，resin等），无法使用nginx等（nginx据说单实例http并发高达5w，这个优势要用上），性能提不上来。 4、第一次请求jsp，必须要在web服务器中编译成servlet，第一次运行会较慢。 5、每次请求jsp都是访问servlet再用输出流输出的html页面，效率没有直接使用html高（是每次哟，亲~）。 6、jsp内有较多标签和表达式，前端工程师在修改页面时会捉襟见肘，遇到很多痛点。 7、如果jsp中的内容很多，页面响应会很慢，因为是同步加载。 8、需要前端工程师使用java的ide（例如eclipse），以及需要配置各种后端的开发环境，你们有考虑过前端工程师的感受吗。 基于上述的一些痛点，我们应该把整个项目的开发权重往前移，实现前后端真正的解耦！ 五、开发模式 以前老的方式是： 123456789101112131415161718191、产品经历/领导/客户提出需求2、UI做出设计图3、前端工程师做html页面4、后端工程师将html页面套成jsp页面（前后端强依赖，后端必须要等前端的html做好才能套jsp。如果html发生变更，就更痛了，开发效率低）5、集成出现问题6、前端返工7、后端返工8、二次集成9、集成成功10、交付 新的方式是： 1234567891011121314151、产品经历/领导/客户提出需求2、UI做出设计图3、前后端约定接口&amp;数据&amp;参数4、前后端并行开发（无强依赖，可前后端并行开发，如果需求变更，只要接口&amp;参数不变，就不用两边都修改代码，开发效率高）5、前后端集成6、前端页面调整7、集成成功8、交付 六、请求方式以前老的方式是：1234567891、客户端请求2、服务端的servlet或controller接收请求（后端控制路由与渲染页面，整个项目开发的权重大部分在后端）3、调用service,dao代码完成业务逻辑4、返回jsp5、jsp展现一些动态的代码 新的方式是：123456789101112131、浏览器发送请求2、直接到达html页面（前端控制路由与渲染页面，整个项目开发的权重前移）3、html页面负责调用服务端接口产生数据（通过ajax等等，后台返回json格式数据，json数据格式因为简洁高效而取代xml）4、填充html，展现动态效果，在页面上进行解析并操作DOM。总结一下新的方式的请求步骤：大量并发浏览器请求—&gt;web服务器集群(nginx)—&gt;应用服务器集群(tomcat)—&gt;文件/数据库/缓存/消息队列服务器集群同时又可以玩分模块，还可以按业务拆成一个个的小集群，为后面的架构升级做准备。 七、前后分离的优势1、可以实现真正的前后端解耦，前端服务器使用nginx。前端/WEB服务器放的是css，js，图片等等一系列静态资源（甚至你还可以css，js，图片等资源放到特定的文件服务器，例如阿里云的oss，并使用cdn加速），前端服务器负责控制页面引用&amp;跳转&amp;路由，前端页面异步调用后端的接口，后端/应用服务器使用tomcat（把tomcat想象成一个数据提供者），加快整体响应速度。（这里需要使用一些前端工程化的框架比如nodejs，react，router，react，redux，webpack） 2、发现bug，可以快速定位是谁的问题，不会出现互相踢皮球的现象。页面逻辑，跳转错误，浏览器兼容性问题，脚本错误，页面样式等问题，全部由前端工程师来负责。接口数据出错，数据没有提交成功，应答超时等问题，全部由后端工程师来解决。双方互不干扰，前端与后端是相亲相爱的一家人。 3、在大并发情况下，我可以同时水平扩展前后端服务器，比如淘宝的一个首页就需要2000+台前端服务器做集群来抗住日均多少亿+的日均pv。（去参加阿里的技术峰会，听他们说他们的web容器都是自己写的，就算他单实例抗10万http并发，2000台是2亿http并发，并且他们还可以根据预知洪峰来无限拓展，很恐怖，就一个首页。。。） 4、减少后端服务器的并发/负载压力。除了接口以外的其他所有http请求全部转移到前端nginx上，接口的请求调用tomcat，参考nginx反向代理tomcat。且除了第一次页面请求外，浏览器会大量调用本地缓存。 5、即使后端服务暂时超时或者宕机了，前端页面也会正常访问，只不过数据刷不出来而已。 6、也许你也需要有微信相关的轻应用，那样你的接口完全可以共用，如果也有app相关的服务，那么只要通过一些代码重构，也可以大量复用接口，提升效率。（多端应用） 7、页面显示的东西再多也不怕，因为是异步加载。 8、nginx支持页面热部署，不用重启服务器，前端升级更无缝。 9、增加代码的维护性&amp;易读性（前后端耦在一起的代码读起来相当费劲）。 10、提升开发效率，因为可以前后端并行开发，而不是像以前的强依赖。 11、在nginx中部署证书，外网使用https访问，并且只开放443和80端口，其他端口一律关闭（防止黑客端口扫描），内网使用http，性能和安全都有保障。 12、前端大量的组件代码得以复用，组件化，提升开发效率，抽出来！ 八、注意事项1、在开需求会议的时候，前后端工程师必须全部参加，并且需要制定好接口文档，后端工程师要写好测试用例（2个维度），不要让前端工程师充当你的专职测试，推荐使用chrome的插件postman或soapui或jmeter，service层的测试用例拿junit写。ps：前端也可以玩单元测试吗？ 2、上述的接口并不是java里的interface，说白了调用接口就是调用你controler里的方法。 3、加重了前端团队的工作量，减轻了后端团队的工作量，提高了性能和可扩展性。 4、我们需要一些前端的框架来解决类似于页面嵌套，分页，页面跳转控制等功能。（上面提到的那些前端框架）。 5、如果你的项目很小，或者是一个单纯的内网项目，那你大可放心，不用任何架构而言，但是如果你的项目是外网项目，呵呵哒。 6、 以前还有人在使用类似于velocity/freemarker等模板框架来生成静态页面，仁者见仁智者见智。 7、这篇文章主要的目的是说jsp在大型外网java web项目中被淘汰掉，可没说jsp可以完全不学，对于一些学生朋友来说，jsp/servlet等相关的java web基础还是要掌握牢的，不然你以为springmvc这种框架是基于什么来写的？ 8、如果页面上有一些权限等等相关的校验，那么这些相关的数据也可以通过ajax从接口里拿。 9、对于既可以前端做也可以后端做的逻辑，我建议是放到前端，为什么？因为你的逻辑需要计算资源进行计算，如果放到后端去run逻辑，则会消耗带宽&amp;内存&amp;cpu等等计算资源，你要记住一点就是服务端的计算资源是有限的，而如果放到前端，使用的是客户端的计算资源，这样你的服务端负载就会下降（高并发场景）。类似于数据校验这种，前后端都需要做！ 10、前端需要有机制应对后端请求超时以及后端服务宕机的情况，友好的展示给用户。 九、扩展阅读1、其实对于js，css，图片这类的静态资源可以考虑放到类似于阿里云的oss这类文件服务器上（如果是普通的服务器&amp;操作系统，存储在到达pb级的文件后，或者单个文件夹内的文件数量达到3-5万，io会有很严重的性能问题），再在oss上配cdn（全国子节点加速），这样你页面打开的速度像飞一样， 无论你在全国的哪个地方，并且你的nginx的负载会进一步降低。 2、如果你要玩轻量级微服务架构，要使用nodejs做网关，用nodejs的好处还有利于seo优化，因为nginx只是向浏览器返回页面静态资源，而国内的搜索引擎爬虫只会抓取静态数据，不会解析页面中的js，这使得应用得不到良好的搜索引擎支持。同时因为nginx不会进行页面的组装渲染，需要把静态页面返回到浏览器，然后完成渲染工作，这加重了浏览器的渲染负担。浏览器发起的请求经过nginx进行分发，URL请求统一分发到nodejs，在nodejs中进行页面组装渲染；API请求则直接发送到后端服务器，完成响应。 3、如果遇到跨域问题，spring4的CORS可以完美解决，但一般使用nginx反向代理都不会有跨域问题，除非你把前端服务和后端服务分成两个域名。JSONP的方式也被淘汰掉了。 4、如果想玩多端应用，注意要去掉tomcat原生的session机制，要使用token机制，使用缓存（因为是分布式系统），做单点，对于token机制的安全性问题，可以搜一下jwt。 5、前端项目中可以加入mock测试（构造虚拟测试对象来模拟后端，可以独立开发和测试），后端需要有详细的测试用例，保证服务的可用性与稳定性。 十、总结前后端分离并非仅仅只是一种开发模式，而是一种架构模式（前后端分离架构）。千万不要以为只有在撸代码的时候把前端和后端分开就是前后端分离了，需要区分前后端项目。前端项目与后端项目是两个项目，放在两个不同的服务器，需要独立部署，两个不同的工程，两个不同的代码库，不同的开发人员。前后端工程师需要约定交互接口，实现并行开发，开发结束后需要进行独立部署，前端通过ajax来调用http请求调用后端的restful api。前端只需要关注页面的样式与动态数据的解析&amp;渲染，而后端专注于具体业务逻辑。 12345关注点分离职责分离对的人做对的事更好的共建模式快速的反应变化","categories":[{"name":"面试题","slug":"面试题","permalink":"https://bolianglll.github.io/categories/面试题/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"https://bolianglll.github.io/tags/面试题/"}]},{"title":"跨域？？？跨域！！！","slug":"跨域？？？跨域！！！","date":"2018-12-27T07:09:21.701Z","updated":"2018-12-27T07:13:15.326Z","comments":true,"path":"2018/12/27/跨域？？？跨域！！！/","link":"","permalink":"https://bolianglll.github.io/2018/12/27/跨域？？？跨域！！！/","excerpt":"身为前端，常遭遇面试题，何为跨域？为何跨域？怎样跨域？一连串的问题扑面而来，背过面试题的肯定就暗自窃喜，没背过的心里一阵阴凉。。。 何为跨域浏览器从一个域名的网页去请求另一个域名的资源时，域名、端口、协议任一不同，都是跨域。 因为浏览器对于javascript的同源策略的限制,例如a.cn下面的js不能调用b.cn中的js,对象或数据(因为a.cn和b.cn是不同域),所以跨域就出现了。","text":"身为前端，常遭遇面试题，何为跨域？为何跨域？怎样跨域？一连串的问题扑面而来，背过面试题的肯定就暗自窃喜，没背过的心里一阵阴凉。。。 何为跨域浏览器从一个域名的网页去请求另一个域名的资源时，域名、端口、协议任一不同，都是跨域。 因为浏览器对于javascript的同源策略的限制,例如a.cn下面的js不能调用b.cn中的js,对象或数据(因为a.cn和b.cn是不同域),所以跨域就出现了。 同源策略请求的url地址,必须与浏览器上的url地址处于同域上,也就是域名,端口,协议相同. 比如:我在本地上的域名是study.cn,请求另外一个域名一段数据 这个时候在浏览器上会报错: 这个就是同源策略的保护,如果浏览器对javascript没有同源策略的保护,那么一些重要的机密网站将会很危险~ 请求地址 形式 结果 http://study.cn/test/a.html 同一域名,不同文件夹 成功 http://study.cn/json/jsonp/jsonp.html 同一域名,统一文件夹 成功 http://a.study.cn/json/jsonp/jsonp.html 不同域名,文件路径相同 失败 http://study.cn:8080/json/jsonp/jsonp.html 同一域名,不同端口 失败 https://study.cn/json/jsonp/jsonp.html 同一域名,不同协议 失败 怎样跨域 通过jsonp跨域 document.domain + iframe跨域 location.hash + iframe window.name + iframe跨域 postMessage跨域 跨域资源共享（CORS） nginx代理跨域 nodejs中间件代理跨域 WebSocket协议跨域 一、通过jsonp跨域通常为了减轻web服务器的负载，我们把js、css，img等静态资源分离到另一台独立域名的服务器上，在html页面中再通过相应的标签从不同域名下加载静态资源，而被浏览器允许，基于此原理，我们可以通过动态创建script，再请求一个带参网址实现跨域通信。 a.原生实现： 12345678910111213&lt;script&gt; var script = document.createElement('script'); script.type = 'text/javascript'; // 传参并指定回调执行函数为onBack script.src = 'http://www.domain2.com:8080/login?user=admin&amp;callback=onBack'; document.head.appendChild(script); // 回调执行函数 function onBack(res) &#123; alert(JSON.stringify(res)); &#125;&lt;/script&gt; 服务端返回如下（返回时即执行全局函数）：1onBack(&#123;\"status\": true, \"user\": \"admin\"&#125;) b.jquery ajax： 1234567$.ajax(&#123; url: 'http://www.domain2.com:8080/login', type: 'get', dataType: 'jsonp', // 请求方式为jsonp jsonpCallback: \"onBack\", // 自定义回调函数名 data: &#123;&#125;&#125;); c.vue.js： 123456this.$http.jsonp('http://www.domain2.com:8080/login', &#123; params: &#123;&#125;, jsonp: 'onBack'&#125;).then((res) =&gt; &#123; console.log(res); &#125;) 后端node.js代码示例： 1234567891011121314151617var querystring = require('querystring');var http = require('http');var server = http.createServer();server.on('request', function(req, res) &#123; var params = qs.parse(req.url.split('?')[1]); var fn = params.callback; // jsonp返回设置 res.writeHead(200, &#123; 'Content-Type': 'text/javascript' &#125;); res.write(fn + '(' + JSON.stringify(params) + ')'); res.end();&#125;);server.listen('8080');console.log('Server is running at port 8080...'); jsonp缺点：只能实现get一种请求 二、 document.domain + iframe跨域此方案仅限主域相同，子域不同的跨域应用场景。 实现原理：两个页面都通过js强制设置document.domain为基础主域，就实现了同域。 a.父窗口：(www.domain.com/a.html) 12345&lt;iframe id=\"iframe\" src=\"http://child.domain.com/b.html\"&gt;&lt;/iframe&gt;&lt;script&gt; document.domain = 'domain.com'; var user = 'admin';&lt;/script&gt; b.子窗口：(child.domain.com/b.html) 12345&lt;script&gt; document.domain = 'domain.com'; // 获取父窗口中变量 alert('get js data from parent ---&gt; ' + window.parent.user);&lt;/script&gt; 三、 location.hash + iframe跨域实现原理： a欲与b跨域相互通信，通过中间页c来实现。 三个页面，不同域之间利用iframe的location.hash传值，相同域之间直接js访问来通信。 具体实现：A域：a.html -&gt; B域：b.html -&gt; A域：c.html，a与b不同域只能通过hash值单向通信，b与c也不同域也只能单向通信，但c与a同域，所以c可通过parent.parent访问a页面所有对象。 a. a.html：(www.domain1.com/a.html) 1234567891011121314&lt;iframe id=\"iframe\" src=\"http://www.domain2.com/b.html\" style=\"display:none;\"&gt;&lt;/iframe&gt;&lt;script&gt; var iframe = document.getElementById('iframe'); // 向b.html传hash值 setTimeout(function() &#123; iframe.src = iframe.src + '#user=admin'; &#125;, 1000); // 开放给同域c.html的回调方法 function onCallback(res) &#123; alert('data from c.html ---&gt; ' + res); &#125;&lt;/script&gt; b. b.html：(www.domain2.com/b.html) 123456789&lt;iframe id=\"iframe\"src=\"http://www.domain1.com/c.html\"style=\"display:none;\"&gt;&lt;/iframe&gt;&lt;script&gt; var iframe = document.getElementById('iframe'); // 监听a.html传来的hash值，再传给c.html window.onhashchange = function () &#123; iframe.src = iframe.src + location.hash; &#125;;&lt;/script&gt; c. c.html：(www.domain1.com/c.html) 1234567&lt;script&gt; // 监听b.html传来的hash值 window.onhashchange = function () &#123; // 再通过操作同域a.html的js回调，将结果传回 window.parent.parent.onCallback('hello: ' + location.hash.replace('#user=', '')); &#125;;&lt;/script&gt; 四、 window.name + iframe跨域window.name属性的独特之处：name值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 name 值（2MB）。 a. a.html：(www.domain1.com/a.html) 12345678910111213141516171819202122232425262728293031323334 var proxy = function(url, callback) &#123; var state = 0; var iframe = document.createElement('iframe'); // 加载跨域页面 iframe.src = url; // onload事件会触发2次，第1次加载跨域页，并留存数据于window.name iframe.onload = function() &#123; if (state === 1) &#123; // 第2次onload(同域proxy页)成功后，读取同域window.name中数据 callback(iframe.contentWindow.name); destoryFrame(); &#125; else if (state === 0) &#123; // 第1次onload(跨域页)成功后，切换到同域代理页面 iframe.contentWindow.location = 'http://www.domain1.com/proxy.html'; state = 1; &#125; &#125;; document.body.appendChild(iframe); // 获取数据以后销毁这个iframe，释放内存；这也保证了安全（不被其他域frame js访问） function destoryFrame() &#123; iframe.contentWindow.document.write(''); iframe.contentWindow.close(); document.body.removeChild(iframe); &#125; // 请求跨域b页面数据 proxy('http://www.domain2.com/b.html', function(data)&#123; alert(data); &#125;);&#125;; b. proxy.html：(www.domain1.com/proxy.... 中间代理页，与a.html同域，内容为空即可。 c. b.html：(www.domain2.com/b.html) 123&lt;script&gt; window.name = 'This is domain2 data!';&lt;/script&gt; 总结：通过iframe的src属性由外域转向本地域，跨域数据即由iframe的window.name从外域传递到本地域。这个就巧妙地绕过了浏览器的跨域访问限制，但同时它又是安全操作。 五、 postMessage跨域postMessage是HTML5 XMLHttpRequest Level 2中的API，且是为数不多可以跨域操作的window属性之一，它可用于解决以下方面的问题：a.） 页面和其打开的新窗口的数据传递b.） 多窗口之间消息传递c.） 页面与嵌套的iframe消息传递d.） 上面三个场景的跨域数据传递 用法：postMessage(data,origin)方法接受两个参数data： html5规范支持任意基本类型或可复制的对象，但部分浏览器只支持字符串，所以传参时最好用JSON.stringify()序列化。origin： 协议+主机+端口号，也可以设置为”*”，表示可以传递给任意窗口，如果要指定和当前窗口同源的话设置为”/“。 a. a.html：(www.domain1.com/a.html) 12345678910111213141516&lt;iframe id=\"iframe\" src=\"http://www.domain2.com/b.html\" style=\"display:none;\"&gt;&lt;/iframe&gt;&lt;script&gt; var iframe = document.getElementById('iframe'); iframe.onload = function() &#123; var data = &#123; name: 'aym' &#125;; // 向domain2传送跨域数据 iframe.contentWindow.postMessage(JSON.stringify(data), 'http://www.domain2.com'); &#125;; // 接受domain2返回数据 window.addEventListener('message', function(e) &#123; alert('data from domain2 ---&gt; ' + e.data); &#125;, false);&lt;/script&gt; b. b.html：(www.domain2.com/b.html) 1234567891011121314&lt;script&gt; // 接收domain1的数据 window.addEventListener('message', function(e) &#123; alert('data from domain1 ---&gt; ' + e.data); var data = JSON.parse(e.data); if (data) &#123; data.number = 16; // 处理后再发回domain1 window.parent.postMessage(JSON.stringify(data), 'http://www.domain1.com'); &#125; &#125;, false);&lt;/script&gt; 六、 跨域资源共享（CORS）普通跨域请求：只服务端设置Access-Control-Allow-Origin即可，前端无须设置。带cookie请求：前后端都需要设置字段，另外需注意：所带cookie为跨域请求接口所在域的cookie，而非当前页。目前，所有浏览器都支持该功能(IE8+：IE8/9需要使用XDomainRequest对象来支持CORS）)，CORS也已经成为主流的跨域解决方案。 1、 前端设置： 1.）原生ajax 12// 前端设置是否带cookiexhr.withCredentials = true; 示例代码： 1234567891011121314var xhr = new XMLHttpRequest(); // IE8/9需用window.XDomainRequest兼容// 前端设置是否带cookiexhr.withCredentials = true;xhr.open('post', 'http://www.domain2.com:8080/login', true);xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');xhr.send('user=admin');xhr.onreadystatechange = function() &#123; if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) &#123; alert(xhr.responseText); &#125;&#125;; 2.）jQuery ajax 12345678$.ajax(&#123; ...xhrFields: &#123; withCredentials: true // 前端设置是否带cookie&#125;,crossDomain: true, // 会让请求头中包含跨域的额外信息，但不会含cookie ...&#125;); 3.）vue框架在vue-resource封装的ajax组件中加入以下代码： 1Vue.http.options.credentials = true 2、 服务端设置：若后端设置成功，前端浏览器控制台则不会出现跨域报错信息，反之，说明没设成功。 1.）Java后台：123456/** 导入包：import javax.servlet.http.HttpServletResponse;* 接口参数中定义：HttpServletResponse response*/response.setHeader(\"Access-Control-Allow-Origin\", \"http://www.domain1.com\"); // 若有端口需写全（协议+域名+端口）response.setHeader(\"Access-Control-Allow-Credentials\", \"true\"); 2.）Nodejs后台示例： 123456789101112131415161718192021222324252627282930var http = require('http');var server = http.createServer();var qs = require('querystring');server.on('request', function(req, res) &#123; var postData = ''; // 数据块接收中 req.addListener('data', function(chunk) &#123; postData += chunk; &#125;); // 数据接收完毕 req.addListener('end', function() &#123; postData = qs.parse(postData); // 跨域后台设置 res.writeHead(200, &#123; 'Access-Control-Allow-Credentials': 'true', // 后端允许发送Cookie 'Access-Control-Allow-Origin': 'http://www.domain1.com', // 允许访问的域（协议+域名+端口） 'Set-Cookie': 'l=a123456;Path=/;Domain=www.domain2.com;HttpOnly' // HttpOnly:脚本无法读取cookie &#125;); res.write(JSON.stringify(postData)); res.end(); &#125;);&#125;);server.listen('8080');console.log('Server is running at port 8080...'); 七、 nginx代理跨域1、 nginx配置解决iconfont跨域 浏览器跨域访问js、css、img等常规静态资源被同源策略许可，但iconfont字体文件(eot|otf|ttf|woff|svg)例外，此时可在nginx的静态资源服务器中加入以下配置。 location / { add_header Access-Control-Allow-Origin *;} 2、 nginx反向代理接口跨域 跨域原理： 同源策略是浏览器的安全策略，不是HTTP协议的一部分。服务器端调用HTTP接口只是使用HTTP协议，不会执行JS脚本，不需要同源策略，也就不存在跨越问题。 实现思路：通过nginx配置一个代理服务器（域名与domain1相同，端口不同）做跳板机，反向代理访问domain2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域登录。 nginx具体配置： 123456789101112131415#proxy服务器server &#123; listen 81; server_name www.domain1.com; location / &#123; proxy_pass http://www.domain2.com:8080; #反向代理 proxy_cookie_domain www.domain2.com www.domain1.com; #修改cookie里域名 index index.html index.htm; # 当用webpack-dev-server等中间件代理接口访问nignx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用 add_header Access-Control-Allow-Origin http://www.domain1.com; #当前端只跨域不带cookie时，可为* add_header Access-Control-Allow-Credentials true; &#125;&#125; 1.) 前端代码示例： 12345678var xhr = new XMLHttpRequest();// 前端开关：浏览器是否读写cookiexhr.withCredentials = true;// 访问nginx中的代理服务器xhr.open('get', 'http://www.domain1.com:81/?user=admin', true);xhr.send(); 2.) Nodejs后台示例： 123456789101112131415161718var http = require('http');var server = http.createServer();var qs = require('querystring');server.on('request', function(req, res) &#123; var params = qs.parse(req.url.substring(2)); // 向前台写cookie res.writeHead(200, &#123; 'Set-Cookie': 'l=a123456;Path=/;Domain=www.domain2.com;HttpOnly' // HttpOnly:脚本无法读取 &#125;); res.write(JSON.stringify(params)); res.end();&#125;);server.listen('8080');console.log('Server is running at port 8080...'); 八、 Nodejs中间件代理跨域node中间件实现跨域代理，原理大致与nginx相同，都是通过启一个代理服务器，实现数据的转发。 1、 非vue框架的跨域（2次跨域） 利用node + express + http-proxy-middleware搭建一个proxy服务器。 1.）前端代码示例： 123456// 前端开关：浏览器是否读写cookiexhr.withCredentials = true;// 访问http-proxy-middleware代理服务器xhr.open('get', 'http://www.domain1.com:3000/login?user=admin', true);xhr.send(); 2.）中间件服务器： 123456789101112131415161718192021var express = require('express');var proxy = require('http-proxy-middleware');var app = express();app.use('/', proxy(&#123; // 代理跨域目标接口 target: 'http://www.domain2.com:8080', changeOrigin: true, // 修改响应头信息，实现跨域并允许带cookie onProxyRes: function(proxyRes, req, res) &#123; res.header('Access-Control-Allow-Origin', 'http://www.domain1.com'); res.header('Access-Control-Allow-Credentials', 'true'); &#125;, // 修改响应信息中的cookie域名 cookieDomainRewrite: 'www.domain1.com' // 可以为false，表示不修改&#125;));app.listen(3000);console.log('Proxy server is listen at port 3000...'); 3.）Nodejs后台同（六：nginx） 2、 vue框架的跨域（1次跨域） 利用node + webpack + webpack-dev-server代理接口跨域。在开发环境下，由于vue渲染服务和接口代理服务都是webpack-dev-server同一个，所以页面与代理接口之间不再跨域，无须设置headers跨域信息了。 webpack.config.js部分配置： 123456789101112131415module.exports = &#123; entry: &#123;&#125;, module: &#123;&#125;, ... devServer: &#123; historyApiFallback: true, proxy: [&#123; context: '/login', target: 'http://www.domain2.com:8080', // 代理跨域目标接口 changeOrigin: true, cookieDomainRewrite: 'www.domain1.com' // 可以为false，表示不修改 &#125;], noInfo: true &#125;&#125; 九、 WebSocket协议跨域WebSocket protocol是HTML5一种新的协议。它实现了浏览器与服务器全双工通信，同时允许跨域通讯，是server push技术的一种很好的实现。原生WebSocket API使用起来不太方便，我们使用Socket.io，它很好地封装了webSocket接口，提供了更简单、灵活的接口，也对不支持webSocket的浏览器提供了向下兼容。 1.）前端代码： 12345678910111213141516171819202122 &lt;div&gt;user input：&lt;input type=\"text\"&gt;&lt;/div&gt; &lt;script src=\"./socket.io.js\"&gt;&lt;/script&gt; &lt;script&gt; var socket = io('http://www.domain2.com:8080'); // 连接成功处理 socket.on('connect', function() &#123; // 监听服务端消息 socket.on('message', function(msg) &#123; console.log('data from server: ---&gt; ' + msg); &#125;); // 监听服务端关闭 socket.on('disconnect', function() &#123; console.log('Server socket has closed.'); &#125;); &#125;); document.getElementsByTagName('input')[0].onblur = function() &#123; socket.send(this.value); &#125;;&lt;/script&gt; 2.）Nodejs socket后台： 123456789101112131415161718192021222324252627var http = require('http');var socket = require('socket.io');// 启http服务var server = http.createServer(function(req, res) &#123; res.writeHead(200, &#123; 'Content-type': 'text/html' &#125;); res.end();&#125;);server.listen('8080');console.log('Server is running at port 8080...');// 监听socket连接socket.listen(server).on('connection', function(client) &#123; // 接收信息 client.on('message', function(msg) &#123; client.send('hello：' + msg); console.log('data from client: ---&gt; ' + msg); &#125;); // 断开处理 client.on('disconnect', function() &#123; console.log('Client socket has closed.'); &#125;);&#125;); 参考链接：http://www.cnblogs.com/roam/p/7520433.html","categories":[{"name":"面试题","slug":"面试题","permalink":"https://bolianglll.github.io/categories/面试题/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"https://bolianglll.github.io/tags/面试题/"}]},{"title":"js如何判断数组是数组？","slug":"js如何判断数组是数组？","date":"2018-12-27T07:09:21.699Z","updated":"2018-12-27T07:13:02.052Z","comments":true,"path":"2018/12/27/js如何判断数组是数组？/","link":"","permalink":"https://bolianglll.github.io/2018/12/27/js如何判断数组是数组？/","excerpt":"这个问题表面看起来好像很容易，其实暗藏玄机。就像别人问你，你是如何证明你是你？（听着想打人了吧，哈哈哈） 下来就来验证一下如何判断数组是数组。 JavaScript有五种方法可以确定一个值到底是什么类型，分别是typeof运算符，constructor法，instanceof运算符，Object.prototype.toString方法以及Array.isArray法.","text":"这个问题表面看起来好像很容易，其实暗藏玄机。就像别人问你，你是如何证明你是你？（听着想打人了吧，哈哈哈） 下来就来验证一下如何判断数组是数组。 JavaScript有五种方法可以确定一个值到底是什么类型，分别是typeof运算符，constructor法，instanceof运算符，Object.prototype.toString方法以及Array.isArray法. 运用typeof运算符来判断先来看看一张包含typeof运算法的针对不同参数的输出结果的表格： 再来看看用typeof是否能判断出数组 123456const a = null;const b = &#123;&#125;;const c= [];console.log(typeof(a)); //Objectconsole.log(typeof(b)); //Objectconsole.log(typeof(c)); //Object 发现了吧，数组被归到了Any other object当中,并没有办法区分数组，对象，null等原型链上都有Object的数据类型。因此，在JavaScript项目中用typeof来判断一个位置类型的数据是否为数组，是非常不靠谱的。 用instanceof判断instanceof运算符可以用来判断某个构造函数的prototype属性所指向的對象是否存在于另外一个要检测对象的原型链上。在使用的时候语法如下： 1object instanceof constructor instanceof 是用来判断 A 是否为 B 的实例，表达式为：A instanceof B，如果 A 是 B 的实例，则返回 true,否则返回 false。 在这里需要特别注意的是：instanceof 检测的是原型。 12345const a = [];const b = &#123;&#125;;console.log(a instanceof Array);//trueconsole.log(a instanceof Object);//true,在数组的原型链上也能找到Object构造函数console.log(b instanceof Array);//false 由上面的几行代码可以看出，使用instanceof运算符可以分辨数组和对象，可以判断数组是数组。 但是这不是精确的 我们用一段伪代码来模拟其内部执行过程： 123456789instanceof (A,B) = &#123; var L = A.__proto__; var R = B.prototype; if(L === R) &#123; //A的内部属性__proto__指向B的原型对象 return true; &#125; return false;&#125; 从上述过程可以看出，当 A 的 proto 指向 B 的 prototype 时，就认为 A 就是 B 的实例，我们再来看几个例子： 12345678910[] instanceof Array; //true&#123;&#125; instanceof Object;//truenew Date() instanceof Date;//truefunction Person()&#123;&#125;;new Person() instanceof Person;[] instanceof Object; //truenew Date() instanceof Object;//truenew Person instanceof Object;//true 我们发现，虽然 instanceof 能够判断出 [ ] 是Array的实例，但它认为 [ ] 也是Object的实例，为什么呢？ 我们来分析一下 [ ]、Array、Object 三者之间的关系： 从 instanceof 能够判断出 [ ].proto 指向 Array.prototype，而 Array.prototype.proto 又指向了Object.prototype，最终 Object.prototype.proto 指向了null，标志着原型链的结束。因此，[]、Array、Object 就在内部形成了一条原型链： 从原型链可以看出，[] 的 proto 直接指向Array.prototype，间接指向 Object.prototype，所以按照 instanceof 的判断规则，[] 就是Object的实例。依次类推，类似的 new Date()、new Person() 也会形成一条对应的原型链 。因此，instanceof 只能用来判断两个对象是否属于实例关系， 而不能判断一个对象实例具体属于哪种类型。 instanceof 操作符的问题在于，它假定只有一个全局执行环境。如果网页中包含多个框架，那实际上就存在两个以上不同的全局执行环境，从而存在两个以上不同版本的构造函数。如果你从一个框架向另一个框架传入一个数组，那么传入的数组与在第二个框架中原生创建的数组分别具有各自不同的构造函数。 为了解决这个问题， ECMAScript 5 新增了 Array.isArray() 方法。这个方法的目的是最终确定某个值到底是不是数组，而不管它是在哪个全局执行环境中创建的。 用Array对象的isArray方法判断当参数为数组的时候，isArray方法返回true，当参数不为数组的时候，isArray方法返回false。 1234const a = [];const b = &#123;&#125;;Array.isArray(a);//trueArray.isArray(b);//false 它与instance运算符判断的方法以及Object.prototype.toString法并不相同，一些列的修改并不会影响到判断的结果。 Array.isArray是ES5标准中增加的方法，部分比较老的浏览器可能会有兼容问题。 用constructor判断实例化的数组拥有一个constructor属性，这个属性指向生成这个数组的方法。 12const a = [];console.log(a.constructor);//function Array()&#123; [native code] &#125; 以上的代码说明，数组是有一个叫Array的函数实例化的。如果被判断的对象是其他的数据类型的话，结果如下： 123456const o = &#123;&#125;;console.log(o.constructor);//function Object()&#123; [native code] &#125;const r = /^[0-9]$/;console.log(r.constructor);//function RegExp() &#123; [native code] &#125;const n = null;console.log(n.constructor);//报错 看到这里，你可能会觉得这也是一种靠谱的判断数组的方法，我们可以用以下的方式来判断: 12const a = [];console.log(a.constructor == Array);//true 但是，很遗憾的通知你，constructor属性是可以改写的，如果你一不小心作死改了constructor属性的话，那么使用这种方法就无法判断出数组的真是身份了，写到这里，我不禁想起了无间道的那段经典对白，梁朝伟：“对不起，我是警察。”刘德华：“谁知道呢？”。 1234567//定义一个数组const a = [];//作死将constructor属性改成了别的a.contrtuctor = Object;console.log(a.constructor == Array);//false (哭脸)console.log(a.constructor == Object);//true (哭脸)console.log(a instanceof Array);//true (instanceof火眼金睛) 可以看出，constructor属性被修改之后，就无法用这个方法判断数组是数组了，除非你能保证不会发生constructor属性被改写的情况，否则用这种方法来判断数组也是不靠谱的。 用Object的toString方法判断 根据对象的class属性(类属性)，跨原型链调用toString()方法。 在js中一个对象一旦被创建，在内部会携带创建对象的类型名，一旦创建就不能被修改了,每一个继承自Object的对象都拥有toString的方法。 如果一个对象的toString方法没有被重写过的话，那么toString方法将会返回”[object type]”，其中的type代表的是对象的类型，根据type的值，我们就可以判断这个疑似数组的对象到底是不是数组了。 你可能会纠结，为什么不是直接调用数组，或则字符串自己的的toString方法呢？我们试一试就知道了。 123456const a = ['Hello','Howard'];const b = &#123;0:'Hello',1:'Howard'&#125;;const c = 'Hello Howard';a.toString();//\"Hello,Howard\"b.toString();//\"[object Object]\"c.toString();//\"Hello,Howard\" 从上面的代码可以看出，除了对象之外，其他的数据类型的toString返回的都是内容的字符串，只有对象的toString方法会返回对象的类型。所以要判断除了对象之外的数据的数据类型，我们需要“借用”对象的toString方法，所以我们需要使用call或者apply方法来改变toString方法的执行上下文。 123456const a = ['Hello','Howard'];const b = &#123;0:'Hello',1:'Howard'&#125;;const c = 'Hello Howard';Object.prototype.toString.call(a);//\"[object Array]\"Object.prototype.toString.call(b);//\"[object Object]\"Object.prototype.toString.call(c);//\"[object String]\" 使用apply方法也能达到同样的效果 总的来看，用es5的isArray以及toString方法是最为靠谱的，其他就不建议拿来用了。 你是不是你，看完有结果了吗？","categories":[{"name":"js","slug":"js","permalink":"https://bolianglll.github.io/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://bolianglll.github.io/tags/js/"}]},{"title":"js数据类型与检测","slug":"js数据类型与检测","date":"2018-12-27T07:09:21.698Z","updated":"2018-12-27T07:12:41.978Z","comments":true,"path":"2018/12/27/js数据类型与检测/","link":"","permalink":"https://bolianglll.github.io/2018/12/27/js数据类型与检测/","excerpt":"在JavaScript中有哪些数据类型?JavaScript中的数据类型有6种：基础数据类型5种：Boolean、String、Number、undefined、null、复杂数据类型1种：Object、如果在ES6中，新增了一种symbol类型，表示独一无二的值。并且symbol类型在初始化的时候不需要使用new操作符。","text":"在JavaScript中有哪些数据类型?JavaScript中的数据类型有6种：基础数据类型5种：Boolean、String、Number、undefined、null、复杂数据类型1种：Object、如果在ES6中，新增了一种symbol类型，表示独一无二的值。并且symbol类型在初始化的时候不需要使用new操作符。 Boolean 除了以下值: undefined null false 0 NaN “” 或者’ ‘其他值都视为true。 空数组和空对象都是true。 String 字符串默认只能写在一行内，分成多行将会报错，如果必须，要在每一行的结尾使用反斜杆，但反斜杆后不能有诸如空格的其他字符。 连接运算符 + 可以连接多个单行字符串，将长字符串拆成多行书写。或者用es6的 ${}字符串模板。 length属性返回字符串长度。 由于历史原因，JavaScript使用Unicode字符集。 Number JavaScript内部，所有数字都是以64位浮点数形式存储，整数也是。 JavaScript能够表示的数值范围是2^-1023到2^1024，超出的范围的数无法表示。 溢出能够表示的范围会返回Infinity（正数）或者0（负数） 数值可以有多种表示方法，字面形式和科学计数法。字面形式：35 0xFF(十六进制) 123e。 除以下情况外都采用字面形式表示，小数点前数字多于21位或后的零多于5个。 有四种进制来表示字面量：十进制 十六进制 八进制 二进制。 属于number类型的特殊数值：-0 +0 NaN 正负Infinity。 NaN参与的绝大部分运算都会得到诸如NaN false 这样的答案。 数值相关的全局方法 parseInt() parseFloat() isNaN() isFinite() null &amp; undefined 都表示没有，在真值判断中都是false，null == undefined，null !== undefined 二者的来由很有历史原因，最开始null用于标识对象为空，这也是现在tyepof null //object的原因，之后又添加了一个undefined类型。 二者的区别，null是一个表示‘空’的对象，转为数值时为0，undefined 是一个表示此处无定义的原始值，转为数值时为NaN。 三大引用类型1.Object类型 我们看到的大多数类型值都是Object类型的实例，创建Object实例的方式有两种。 第一种是使用new操作符后跟Object构造函数，如下所示 12345var person = new Object();person.name = \"Micheal\";person.age = 24; 第二种方式是使用对象字面量表示法，如下所示 1234567var person = &#123; name : \"Micheal\", age : 24&#125;; 2.Array类型 数组的每一项可以用来保存任何类型的数据，也就是说，可以用数组的第一个位置来保存字符串，第二个位置保存数值，第三个位置保存对象….另外，数组的大小是可以动态调整的。 创建数组的基本方式有两种 第一种是使用Array构造函数，如下所示 1var colors = new Array(\"red\",\"blue\",\"yellow\"); 第二种是使用数组字面量表示法，如下所示 1var colors = [\"red\",\"blue\",\"yellow\"]; 3 Function类型 每个函数都是Function类型的实例，而且都与其他引用类型一样具有属性和方法。函数通常是使用函数声明语法定义的，如下所示 12345function sum(num1,num2)&#123; return num1 + num2;&#125;; 这和使用函数表达式定义函数的方式相差无几。 12345var sun = function ()&#123; return sum1 + sum2;&#125;; js按照存储方式分为值类型和引用类型,下一篇文章会讲到浅拷贝深拷贝。 如何对数据类型进行判断？123456typeof (true); //\"boolean\"typeof (\"xwj\"); //\"string\"typeof (10); //\"number\"typeof (undefined); //\"undefined\"typeof (null); //\"object\"typeof (&#123;&#125;); //\"object\" 对于普通的数据类型来说，只需要使用typeof来进行判断就可以来，数据类型有6种，typeofde返回的值也有6种(在es6中是7种，包括symbol类型的返回值)，但是在typeof的返回值里面，null和Object返回的都是Object，而其余的都是对应的字符串，包括function 12function a () &#123;&#125;typeof a; //\"function\" typeof后面经常会跟一个（），这对括号可否省略？先想想typeof到底是什么？它的后面经常跟一对（），看起来确实有点像一个函数，但其实不然，typeof它是一个一元运算符，和+ - * / 是一样的，所以typeof后面是可以不跟（）的，加（）只是为了看起来方便，不过这也造成了一些误解，但它就是一个一元运算符。 一元运算符有很高的优先级，即使我们做多个 &amp;&amp; || 的逻辑判断时，typeof依然可以连着写，而不需要使用（）把每一个typeof包裹起来 那么如何对Object类型进行判断？其实对Object判断主要是区分某个对象是否为数组，有以下方法： 1.使用instanceof判断 1console.log(a instanceof Array); //true 2.使用原型链上的constructor判断 console.log(a.proto.constructor===Array); //true 这两种方法，看上去不错，但是实际上还是有些漏洞的，当我们的页面中存在多个frame，并且我们的判断是在两个iframe之间的时候，就很有可能出现问题了。由于每个iframe都属于自己的window对象，跨frame实例化的对象彼此是不共享原型链的，因此导致上述检测代码失效 123456var iframe = document.createElement('iframe'); //创建iframedocument.body.appendChild(iframe); //添加到body中xArray = window.frames[window.frames.length-1].Array; //将xArray指向第二个iframe的引用var arr = new xArray(1,2,3); // 声明数组[1,2,3]alert(arr instanceof Array); // falsealert(arr.constructor === Array); // false 还有两种更值得推荐的方法： 3.使用Array.isArray() 方法判断 12var a = [];console.log(Array.isArray(a)); //true ECMAScript 5加入了 Array.isArray() 方法，可以准确地检测一个值是否为数组。但是它有个缺点就是不支持IE8之前的版本，不过现在连淘宝都放弃了对IE8以下浏览器的支持，这个问题大概可以忽略 4.使用Object.prototype.toString.call()方法判断 这是一种无懈可击的判断数组的方法，所有typeof返回值为”object”的对象都有一个内置属性：[[Class]] Object.prototype.toString()获取到这个内置属性，然后根据它返回类似于”[object Array]”的字符串作为结果，利用这个方法，再配合call改变toString的this引用为待检测的对象，我们可以取得任何对象的内部属性[[Class]] 123456var a = &#123;&#125;;var b = [];function c () &#123;&#125;console.log(Object.prototype.toString.call(a)); //[Object Object]console.log(Object.prototype.toString.call(b)); //[Object Array]console.log(Object.prototype.toString.call(c)); // Object.prototype.toString方法在ECMAScript 3中规范中就存在，也不存在兼容性问题。 本文总结：js数据类型虽然是基础，但面试题也经常出现，偶尔回来温习一下巩固下基础对自己的发展也是有好处的。","categories":[{"name":"js","slug":"js","permalink":"https://bolianglll.github.io/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://bolianglll.github.io/tags/js/"}]},{"title":"前端性能优化总结","slug":"前端性能优化总结","date":"2018-12-27T07:09:21.696Z","updated":"2018-12-27T07:12:14.361Z","comments":true,"path":"2018/12/27/前端性能优化总结/","link":"","permalink":"https://bolianglll.github.io/2018/12/27/前端性能优化总结/","excerpt":"总结一波前端性能优化,传说中的雅虎军规，其实前端小白的我还不知道啥是雅虎军规，上网找了一些前端优化的问题才看到，百度一波猛然大悟，既然有前人给我们填坑，那肯定是要站在巨人的肩膀上去跳坑啦。 本文简单罗列了雅虎军规（35条），再加上本人的一些理解和看法。","text":"总结一波前端性能优化,传说中的雅虎军规，其实前端小白的我还不知道啥是雅虎军规，上网找了一些前端优化的问题才看到，百度一波猛然大悟，既然有前人给我们填坑，那肯定是要站在巨人的肩膀上去跳坑啦。 本文简单罗列了雅虎军规（35条），再加上本人的一些理解和看法。 雅虎军规1234567891011121314151617181920212223242526272829303132333435尽量减少 HTTP 请求个数——须权衡使用 CDN（内容分发网络）为文件头指定 Expires 或 Cache-Control ，使内容具有缓存性。避免空的 src 和 href使用 gzip 压缩内容把 CSS 放到顶部把 JS 放到底部避免使用 CSS 表达式将 CSS 和 JS 放到外部文件中减少 DNS 查找次数精简 CSS 和 JS避免跳转剔除重复的 JS 和 CSS配置 ETags使 AJAX 可缓存尽早刷新输出缓冲使用 GET 来完成 AJAX 请求延迟加载预加载减少 DOM 元素个数根据域名划分页面内容尽量减少 iframe 的个数避免 404减少 Cookie 的大小使用无 cookie 的域减少 DOM 访问开发智能事件处理程序用&lt;link&gt;代替 @import避免使用滤镜优化图像优化 CSS Spirite不要在 HTML 中缩放图像——须权衡favicon.ico要小而且可缓存保持单个内容小于25K打包组件成复合文本 1、尽量减少HTTP请求个数——须权衡 合并图片（如css sprites，内置图片使用数据）、合并CSS、JS，这一点很重要，但是要考虑合并后的文件体积。 2、使用CDN（内容分发网络） 这里可以关注CDN的三类实现：镜像、高速缓存、专线，以及智能路由器和负载均衡； 3、为文件头指定Expires或Cache-Control，使内容具有缓存性。 区分静态内容和动态内容，避免以后页面访问中不必要的HTTP请求。 4、避免空的src和href 留意具有这两个属性的标签如link，script，img，iframe等； 5、使用gzip压缩内容 Gzip压缩所有可能的文件类型以来减少文件体积 6、把CSS放到顶部 实现页面有秩序地加载，这对于拥有较多内容的页面和网速较慢的用户来说更为重要，同时，HTML规范清楚指出样式表要放包含在页面的区域内； 7、把JS放到底部 HTTP/1.1 规范建议，浏览器每个主机名的并行下载内容不超过两个，而问题在于脚本阻止了页面的平行下载，即便是主机名不相同 8、避免使用CSS表达式 页面显示和缩放，滚动、乃至移动鼠标时，CSS表达式的计算频率是我们要关注的。可以考虑一次性的表达式或者使用事件句柄来代替CSS表达式。 9、将CSS和JS放到外部文件中 我们需要权衡内置代码带来的HTTP请求减少与通过使用外部文件进行缓存带来的好处的折中点。 10、减少DNS查找次数 我们需要权衡减少 DNS查找次数和保持较高程度并行下载两者之间的关系。 11、精简CSS和JS 目的就是减少下载的文件体积，可考虑压缩工具JSMin和YUICompressor。 12、避免跳转 为了确保“后退”按钮可以正确地使用，使用标准的 3XXHTTP状态代码；同域中注意避免反斜杠 “/” 的跳转；跨域使用 Alias或者 mod_rewirte建立 CNAME（保存一个域名和另外一个域名之间关系的DNS记录） 13、剔除重复的JS和CSS 重复调用脚本，除了增加额外的HTTP请求外，多次运算也会浪费时间。在IE和Firefox中不管脚本是否可缓存，它们都存在重复运算JavaScript的问题。 14、配置ETags Entity tags（ETags）（实体标签）是web服务器和浏览器用于判断浏览器缓存中的内容和服务器中的原始内容是否匹配的一种机制（“实体”就是所说的“内 容”，包括图片、脚本、样式表等），是比last-modified date更更加灵活的机制，单位时间内文件被修过多次，Etag可以综合Inode(文件的索引节点(inode)数)，MTime(修改时间)和Size来精准的进行判断，避开UNIX记录MTime只能精确到秒的问题。 服务器集群使用，可取后两个参数。使用ETags减少Web应用带宽和负载。 15、使AJAX可缓存 利用时间戳，更精巧的实现响应可缓存与服务器数据同步更新。 16、尽早刷新输出缓冲 尤其对于css，js文件的并行下载更有意义 17、使用GET来完成AJAX请求 当使用XMLHttpRequest时，浏览器中的POST方法是一个“两步走”的过程：首先发送文件头，然后才发送数据。在url小于2K时使用GET获取数据时更加有意义。 18、延迟加载 确定页面运行正常后，再加载脚本来实现如拖放和动画，或者是隐藏部分的内容以及折叠内容等。 19、预加载 关注下无条件加载，有条件加载和有预期的加载。 20、减少DOM元素个数 使用更适合或者在语意是更贴切的标签，要考虑大量DOM元素中循环的性能开销。 21、根据域名划分页面内容 很显然， 是最大限度地实现平行下载 22、尽量减少iframe的个数 考虑即使内容为空，加载也需要时间，会阻止页面加载，没有语意，注意iframe相对于其他DOM元素高出1-2个数量级的开销，它会在典型方式下阻塞onload事件，IE和Firefox中主页面样式表会阻塞它的下载。 23、避免404 HTTP请求时间消耗是很大的，有些站点把404错误响应页面改为“你是不是要找***”，这虽然改进了用户体验但是同样也会浪费服务器资源（如数据库等）。最糟糕的情况是指向外部 JavaScript的链接出现问题并返回404代码。首先，这种加载会破坏并行加载；其次浏览器会把试图在返回的404响应内容中找到可能有用的部分当作JavaScript代码来执行。 24、减少Cookie的大小 去除不必要的coockie使coockie体积尽量小以减少对用户响应的影响注意在适应级别的域名上设置coockie以便使子域名不受影响设置合理的过期时间。较早地Expire时间和不要过早去清除coockie，都会改善用户的响应时间。 25、使用无cookie的域 确定对于静态内容的请求是无coockie的请求。创建一个子域名并用他来存放所有静态内容。 26、减少DOM访问 缓存已经访问过的有关元素线下更新完节点之后再将它们添加到文档树中避免使用JavaScript来修改页面布局 27、开发智能事件处理程序 有时候我们会感觉到页面反应迟钝，这是因为DOM树元素中附加了过多的事件句柄并且些事件句病被频繁地触发。这就是为什么说使用event delegation（事件代理）是一种好方法了。如果你在一个div中有10个按钮，你只需要在div上附加一次事件句柄就可以了，而不用去为每一个按 钮增加一个句柄。事件冒泡时你可以捕捉到事件并判断出是哪个事件发出的。你同样也不用为了操作DOM树而等待onload事件的发生。你需要做的就是等待树结构中你要访问的元素出现。你也不用等待所有图像都加载完毕。你可能会希望用DOMContentLoaded事件来代替 事件应用程序中的onAvailable方法。 28、用&lt; link &gt;代替@import 在IE中，页面底部@import和使用&lt; link &gt;作用是一样的，因此最好不要使用它。 29、避免使用滤镜 完全避免使用AlphaImageLoader的最好方法就是使用PNG8格式来代替，这种格式能在IE中很好地工作。如果你确实需要使用 AlphaImageLoader，请使用下划线_filter又使之对IE7以上版本的用户无效。 30、优化图像 尝试把GIF格式转换成PNG格式，看看是否节省空间。在所有的PNG图片上运行pngcrush（或者其它PNG优化工具） 31、优化CSS Spirite 在Spirite中水平排列你的图片，垂直排列会稍稍增加文件大小；Spirite中把颜色较近的组合在一起可以降低颜色数，理想状况是低于256色以便适用PNG8格式；便于移动，不要在Spirite的图像中间留有较大空隙。这虽然不大会增加文件大小但对于用户代理来说它需要更少的内存来把图片解压为像素地图。 100×100的图片为1万像素，而1000×1000就是100万像素。 32、不要在HTML中缩放图像——须权衡 不要为了在HTML中设置长宽而使用比实际需要大的图片。 33、favicon.ico要小而且可缓存 favicon.ico是位于服务器根目录下的一个图片文件。它是必定存在的，因为即使你不关心它是否有用，浏览器也会对它发出请求，因此最好不要返回一 个404 Not Found的响应。由于是在同一台服务器上，它每被请求一次coockie就会被发送一次。这个图片文件还会影响下载顺序，例如在IE中当你在 onload中请求额外的文件时，favicon会在这些额外内容被加载前下载。 因此，为了减少favicon.ico带来的弊端，要做到：文件尽量地小，最好小于1K在适当的时候（也就是你不要打算再换favicon.ico的时候，因为更换新文件时不能对它进行重命名）为它设置Expires文件头。你可以很安全地 把Expires文件头设置为未来的几个月。你可以通过核对当前favicon.ico的上次编辑时间来作出判断。Imagemagick可以帮你创建小巧的favicon。 34、保持单个内容小于25K 因为iPhone不能缓存大于25K的文件。注意这里指的是解压缩后的大小。由于单纯gizp压缩可能达不要求，因此精简文件就显得十分重 要。 35、打包组件成复合文本 页面内容打包成复合文本就如同带有多附件的Email，它能够使你在一个HTTP请求中取得多个组件（切记：HTTP请求是很奢侈的）。当你使用这条规 则时，首先要确定用户代理是否支持（iPhone就不支持）。 使用 Webpack 优化项目 对于 Webpack4，打包项目使用 production 模式，这样会自动开启代码压缩 使用 ES6 模块来开启 tree shaking，这个技术可以移除没有使用的代码 优化图片，对于小图可以使用 base64 的方式写入文件中 按照路由拆分代码，实现按需加载 给打包出来的文件名添加哈希，实现浏览器缓存文件","categories":[{"name":"前端优化","slug":"前端优化","permalink":"https://bolianglll.github.io/categories/前端优化/"}],"tags":[{"name":"性能","slug":"性能","permalink":"https://bolianglll.github.io/tags/性能/"}]},{"title":"输入URL到浏览器经过了哪些过程？如何渲染以及优化？","slug":"输入URL到浏览器经过了哪些过程？如何渲染以及优化？","date":"2018-12-27T07:09:21.694Z","updated":"2018-12-27T07:11:54.693Z","comments":true,"path":"2018/12/27/输入URL到浏览器经过了哪些过程？如何渲染以及优化？/","link":"","permalink":"https://bolianglll.github.io/2018/12/27/输入URL到浏览器经过了哪些过程？如何渲染以及优化？/","excerpt":"主要问题 从用户输入URL到浏览器呈现页面经过了哪些过程？ 页面渲染的完整流程是怎样的？ 前端性能优化有哪些经验？ 文章提纲：1.TCP2.UDP3.套接字socket4.HTTP协议5.DNS解析6.HTTP请求发起和响应7.页面渲染的过程8.页面的性能优化","text":"主要问题 从用户输入URL到浏览器呈现页面经过了哪些过程？ 页面渲染的完整流程是怎样的？ 前端性能优化有哪些经验？ 文章提纲：1.TCP2.UDP3.套接字socket4.HTTP协议5.DNS解析6.HTTP请求发起和响应7.页面渲染的过程8.页面的性能优化 TCP连接TCP：Transmission Control Protocol， 传输控制协议，是一种面向连接的、可靠的、基于字节流的传输层通信协议。说的这么专业，有啥用呢？先来举个栗子吧还记得小时候我们做的纸杯电话么？两个纸杯用一条绳子连到一起，两个各拿一个纸杯把线拉直，一个对着纸杯讲，一个用耳朵对着纸杯听。 这其实就是一种最简单的连接通信，两人通过一根线连接起来，声音从这边的纸杯发出通过线传输到另一个纸杯接收，扩展到现在家家户户都有的固定电话也是如此，它的通信也是建立在双方可接受并且信任的基础上进行，如： 1、 A拿起电话，拨通0775-6532122，开始呼叫B2、 B听到电话声响起，拿起电话，此时A收到B已经拿起电话的声音3、 双方开始讲话。 回到我们的tcp协议，其实它和上面所说的电话协议差不多，只不过电话的协议是服务于电话通信，而tcp是服务于网络通讯的一种协议，类似的，通讯双方建立一次tcp连接，也需要经过三个步骤（握手）。 1、 客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认。2、 服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态。3、 客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。 上面几个唧唧歪歪的英文看的有点懵逼，翻译一下吧： (大家最好记一下这些状态码，在服务器连接数的性能优化中会经常用到) SYN:synchronous 建立联机A CK:acknowledgement 确认SYN_SENT:请求连接 SYN_RECV:服务端被动打开后,接收到了客户端的SYN并且发送了ACK时的状态。再进一步接收到客户端的ACK就进入&gt;ESTABLISHED状态。 值得注意的是：tcp在握手过程中并不携带数据，(就像你打电话给酒店订房时，在确认对方是酒店客服人员之前，你也不会马上把身份证号码报给他吧？)，而是在三次握手完成之后，才会进行数据传送。 至于它的应用场景，其实是根据它本身的特点而定的，比如对网络通讯质量有要求，需要保证数据准确性时，就需要用到TCP协议了，如HTTP、ftp等文件传输协议、或一些邮件传输协议（SMTP、pop等） UDP协议(UDP协议并非本文需要重点着笔的内容，但是讲到TCP了，作为他的互补兄弟，在此掠过一笔) UDP：User Datagram Protocol 用户数据报协议相比于TCP的面向连接需要反复确认的繁琐步骤，UDP是一中性格特立独行并且主观性超强的非面向连接的协议，使用udp协议经常通信并不需要建立连接，它只是负责把数据尽可能快的发送出去，简单粗暴，并且不可靠，而在接收端，UDP把每个消息断放入队列中，接收端程序从队列中读取数据。有人会说，UDP协议这么不可靠，为啥还会造出来呢？话说回来，天底下没有无用之人，只有你不懂用的人而已，虽然UDP不可靠，但是它的传输速度快，效率高，在一些对数据准确性要求不高的场景，UDP就变得很有用了，比如qq语音、qq视频。 套接字socket为什么要说嵌套字？那是因为就像前面说的，TCP或UDP都是一种协议，也就是计算机网络通信中在传输层的一种协议，简单地说，就是一种约定，就像合作双方的合同一样，然后合同是死的，只有履行合同才是实质性的行动，因此无论是TCP还是UDP要产生作用，都需要有实际的行为去执行才能体现协议的作用，那么，有什么办法让这些协议作用呢？这就要说到socket了。 socket：也叫嵌套字 ，是一组实现TCP/UDP通信的接口API，也就是说无论TCP还是UDP，通过对scoket的编程，都可以实现TCP/UCP通信，作为一个通信链的句柄，它包含网络通信必备的5种信息： 1、 连接使用的协议2、 本地主机的IP地址3、 本地进程的协议端口4、 远地主机的IP地址5、 远地进程的协议端口 可见，socket包含了通信本方和对方的ip和端口以及连接使用的协议（TCP/UDP）。通信双方中的一方（暂称：客户端）通过scoket（嵌套字）对另一方（暂称：服务端）发起连接请求，服务端在网络上监听请求，当收到客户端发来的请求之后，根据socket里携带的信息，定位到客户端，就相应请求，把socket描述发给客户端，双方确认之后连接就建立了。因此套接字之间的连接过程有三个步骤： 1、 服务器监听:服务器实时监控网络状态等待客户端发来的连接请求2、 客户端请求:客户端根据远程主机服务器的IP地址和协议端口向其发起连接请求3、 连接确认:服务端收到套接字的连接请求之后，就响应请求，把服务端套4、 接字描述发给客户端，客户端收到后一旦确认，则双方建立连接，进行数据交互。 通常情况下socket连接就是TCP连接，因此socket连接一旦建立,通讯双方开始互发数据进行通信，直到其中一方或双方断开连接为止。 socket在即时通讯（qq等各种聊天软件）等应用上应用广泛。 HTTP协议HTTP协议：Hypertext Transfer Protocol 也叫超文本传送协议 ，它是一种基于TCP/IP协议栈、在表示层和应用层上的协议（TCP在传输层的协议），通俗一点说就是： TCP/IP是位于传输层上的一种协议，用于在网络中传输数据；HTTP协议是应用层协议，基于TCP协议，\b用于包装数据，程序使用它进行通信，可以简单高效的处理通信中数据的传输和识别处理 而在现在应用非常广泛的HTTP连接则是建立在HTTP协议上的、处于应用层中的一种具体应用。上面说到socket连接一旦建立就保持连接状态，而HTTP连接则不一样，它基于tcp协议的短连接，也就是客户端发起请求，服务器响应请求之后，连接就会自动断开，不会一直保持 URL前面讲了tcp、udp、http…等等都是为了讲一个具体问题而做的知识点铺垫，那就是：我们开发的web应用中请求的发起和响应，是一个怎样的底层原理。我们都知道，web应用绝大部分都是通过HTTP来进行请求的，而URL则是HTTP用来做连接建立和传输数据的一种具体实现，因此在此要简单讲一下URL。 URL：Uniform Resource Locator 统一资源定位符。说白了就是网络上用来标识具体资源的一个地址，包含了用户查找该资源的信息，HTTP使用它来传输数据和建立连接一个URL有以下组成部分： 1、协议2、服务器地址（域名或IP+端口）3、路径4、文件名 比如：https://www.baidu.com/index.html其中 1、https://是一种协议 当然，HTTP也是 ftp也是…2、www.baidu.com 是服务器地址，当然你知道百度的IP也可以,例如我用ing命令得到百度的ip14.215.177.39，那么我可用http://14.215.177.39 打开百度3、index.html包含了路径和文件名，当然通常index.html是可以省略的，所以你打开百度时，并没有看到这个。 DNSDNS: Domain Name Server，域名服务器。是进行域名(domain name)和与之相对应的IP地址 (IP address)转换的服务器。DNS中保存了一张域名(domain name)和与之相对应的IP地址 (IP address)的表，以解析消息的域名。在平时我们进行开发时，后端提供的接口地址通常是有IP地址加上端口号（8080什么鬼的）组成的，但是当我们把网站发布出去时，通常都需要把IP改成用域名。为什么呢？你想想哦，比如谷歌的地址是89.12.21.221:9090,百度的地址是132.21.33.221:8766。。。这么一看你根本没有欲望是记住这些乱七八糟的数字吧？但是域名就不一样了，比如谷歌的google.com，百度的baidu.com 是不是一遍就记住了呢？所以为了处理这个问题，就需要用域名去映射IP地址，达到易记易用的目的。 因此，当用户在浏览器输入https://www.baidu.com回车时，它经历了以下步骤： 1、浏览器根据地址去本身缓存中查找dns解析记录，如果有，则直接返回IP地址，否则浏览器会查找操作系统中（hosts文件）是否有该域名的dns解析记录，如果有则返回。2、如果浏览器缓存和操作系统hosts中均无该域名的dns解析记录，或者已经过期，此时就会向域名服务器发起请求来解析这个域名。3、请求会先到LDNS（本地域名服务器），让它来尝试解析这个域名，如果LDNS也解析不了，则直接到根域名解析器请求解析4、根域名服务器给LDNS返回一个所查询余的主域名服务器（gTLDServer）地址。5、此时LDNS再向上一步返回的gTLD服务器发起解析请求。6、gTLD服务器接收到解析请求后查找并返回此域名对应的Name Server域名服务器的地址，这个Name Server通常就是你注册的域名服务器（比如阿里dns、腾讯dns等）6、Name Server域名服务器会查询存储的域名和IP的映射关系表，正常情况下都根据域名得到目标IP记录，连同一个TTL值返回给DNS Server域名服务器7、返回该域名对应的IP和TTL值，Local DNS Server会缓存这个域名和IP的对应关系，缓存的时间有TTL值控制。8、把解析的结果返回给用户，用户根据TTL值缓存在本地系统缓存中，域名解析过程结束。 HTTP请求发起和响应如果这篇文章的主题是网络通信，那到这里已经可以告一段落了，但今天我们要讲的是web应用中请求的发起和响应以及页面渲染的原理，因此以上只是铺垫。在一个web程序开发中，一般都有前端和后端之分，前端负责向后端请求数据和展示页面，后端负责接收请求和做出响应发回给前端，他们之间的协作的桥梁是什么呢？是APIAPI是什么？不就是一个URL吗？URL又是啥呢？上面说到就是HTTP连接的一种具体的载体因此，无论对于前端或者是后端，理解HTTP，无论是对自身对编程的理解，还是和同事协作，都是好处大大的，下面，根据上面各个知识点的理解，我们来整理一下并解决一下上面提到的第一个问题：从用户输入URL，到浏览器呈现给用户页面，经过了什么过程? 1、用户输入URL，浏览器获取到URL2、浏览器(应用层)进行DNS解析（如果输入的是IP地址，此步骤省略）3、根据解析出的IP地址+端口，浏览器（应用层）发起HTTP请求，请求中携带（请求头header（也可细分为请求行和请求头）、请求体body）， header包含： 1、请求的方法（get、post、put..） 2、协议（http、https、ftp、sftp…） 3、目标url（具体的请求路径已经文件名） 4、一些必要信息（缓存、cookie之类） body包含： 1、请求的内容 4、请求到达传输层，tcp协议为传输报文提供可靠的字节流传输服务，它通过三次握手等手段来保证传输过程中的安全可靠。通过对大块数据的分割成一个个报文段的方式提供给大量数据的便携传输。5、到网络层， 网络层通过ARP寻址得到接收方的Mac地址，IP协议把在传输层被分割成一个个数据包传送接收方。6、数据到达数据链路层，请求阶段完成7、接收方在数据链路层收到数据包之后，层层传递到应用层，接收方应用程序就获得到请求报文。8、接收方收到发送方的HTTP请求之后，进行请求文件资源（如HTML页面）的寻找并响应报文9、发送方收到响应报文后，如果报文中的状态码表示请求成功，则接受返回的资源（如HTML文件），进行页面渲染。 页面的渲染当一个请求的发起和响应都完成之后，浏览器就会收到响应内容，但浏览器收到的是一串串的代码或URL链接，怎么把这些代码转化成用户可以看得懂的界面呈现出来，就是浏览器的工作了。目前市场上的浏览器已经不下百种，各个浏览器根据内核又可以分成几大类，每一类浏览器对页面的渲染原理和过程有所差异。 但总的来说，各个浏览器渲染页面都基本遵循如下图的流程： 图中有几处英文词汇可能不好理解，没关系，先做一下解释： 1、HTML parser：HTML解析器，其本质是将HTML文本解释成DOM tree。2、CSS parser：CSS解析器，其本质是讲DOM中各元素对象加入样式信息3、JavaScript引擎：专门处理JavaScript脚本的虚拟机，其本质是解析JS代码并且把逻辑（HTML和CSS的操作）应用到布局中，从而按程序要的要求呈现相应的结果4、DOM tree:文档对象模型树，也就是浏览器通过HTMLparser解析HTML页面生成的HTML树状结构以及相应的接口。5、render tree：渲染树，也就是浏览器引擎通过DOM Tree和CSS Rule Tree构建出来的一个树状结构，和dom tree不一样的是，它只有要最终呈现出来的内容，像或者带有display:none的节点是不存在render tree中的。6、layout：也叫reflow 重排，渲染中的一种行为。当rendertree中任一节点的几何尺寸发生改变了，render tree都会重新布局。7、repaint：重绘，渲染中的一种行为。render tree中任一元素样式属性（几何尺寸没改变）发生改变了，render tree都会重新画，比如字体颜色、背景等变化。 所以，根据关键词汇的解释以及顺着流程图的流程，可以总结出，浏览器解析渲染页面主要包括以下过程： 1、览器通过HTMLParser根据深度遍历的原则把HTML解析成DOM Tree。2、将CSS解析成CSS Rule Tree（CSSOM Tree）。3、根据DOM树和CSSOM树来构造render Tree。4、layout：根据得到的render tree来计算所有节点在屏幕的位置。5、paint：遍历render树，并调用硬件图形API来绘制每个节点。 前端性能优化对于页面渲染基本上这样就是一个的流程，看完之后，有没有什么感觉在实际编码中可以优化的点呢？没有吧？因为很多细节都没有讲述，因此为了找到可优化的点，在此对页面渲染过程的几个关键步骤做一下陈述： HTML解析： 上面讲到，HTML解析是浏览器的HTML解析器把HTML解析成dom tree，而在解析过程，浏览器根据HTML文件的结构从上到下解析html，HTML元素是以深度优先的方式解析，而script、link、style等标签会使解析过程产生阻塞，阻塞的情况有： 1、外部样式会阻塞内部脚本的执行。2、外部样式与外部脚本并行加载，但外部样式会阻塞外部脚本执行。3、如果外部脚本带有async属性，则外部脚本的加载与执行不受外部样式影响4、如果link标签是动态创建（js生成），不管有无async属性，都不会阻塞外部脚本的加载与执行。 CSS解析: CSS Parser作用就是将很多个CSS文件中的样式合并解析出具有树形结构Style Rules，在对样式解析的过程中，默认CSS选择器是从右往左进行解析的。至于为什么是从右到左，而不是从左到右、也是不会从左到左…下面举个栗子来说一下：假如现在有这样的一个样式: 12345parent .ch1 .dh1 &#123;&#125;fh1 .ch1 .dh1&#123;&#125;ah1 .ch1 .eh1 &#123;&#125;parent .fh1 &#123;&#125;ch1 .dh1&#123;&#125; 我们来比较从左到右和从右到左两种方式的结果： 从两个图的比较就可以看几点： 1、右边的tree复杂度要比左边的低2、右边的tree公用样式重合度比左边的低3、右边的tree从根开始的节点数要比左边的少 可能光看这几点没看出什么问题，但你要知道：浏览器中的css解析器负责css的解析，并为每个节点计算出样式，因此虽然css解析器要做的事情不多，但要每个节点都要进行遍历查找计算，计算量极大，因此解析的方式是决定其性能的关键点。就如 12parant .a&#123;&#125;.a&#123;&#125; 估计绝大多数人都会认为前者要比后者性能更优，其实不然，在解析过程中 #paran .a{}意味着css解析器要先找到#parent再找到他下面的.a所在节点而后者可以直接定位到.a{}因此哪一种方式更优，显而易见。 脚本执行:浏览器解析HTML时，当遇到&lt;script&gt;标签就会立即解析脚本，同时阻塞解析文档直到脚本执行完毕（你可能问为什么要这样设计，明显啊，脚本的执行是改变css和dom，会造成render tree不停的重绘和重排的），而当&lt;script&gt;是引入外部js文件时，会阻塞到js文件下载完成并且执行完成为止（除非加了defer或者async属性）。脚本在解析过程中将对dom或css的操作解析出来加入到DOM Tree和cssom中。 性能优化把这些度讲完之后，对于性能优化的点，相信大家心里都有点X数了吧，下面简单总结一下日常开发过程中常用的性能优化的地方： 1.对于css 1、优化选择器路径：健全的css选择器固然是能让开发看起来更清晰，然后对于css的解析来说却是个很大的性能问题，因此相比于 .a .b .c{} ，更倾向于大家写.c{}。2、压缩文件：尽可能的压缩你的css文件大小，减少资源下载的负担。3、选择器合并：把有共同的属性内容的一系列选择器组合到一起，能压缩空间和资源开销4、精准样式：尽可能减少不必要的属性设置，比如你只要设置{padding-left:10px}的值,那就避免{padding:0 0 0 10px}这样的写法5、雪碧图：在合理的地方把一些小的图标合并到一张图中，这样所有的图片只需要一次请求，然后通过定位的方式获取相应的图标，这样能避免一个图标一次请求的资源浪费。6、避免通配符：.a .b {} 像这样的选择器，根据从右到左的解析顺序在解析过程中遇到通配符（）回去遍历整个dom的，这样性能问题就大大的了。7、少用Float:Float在渲染时计算量比较大，尽量减少使用。8、0值去单位：对于为0的值，尽量不要加单位，增加兼容性 2.对于JavaScript： 1、尽可能把script标签放到body之后，避免页面需要等待js执行完成之后dom才能继续执行，最大程度保证页面尽快的展示出来。2、尽可能合并script代码，3、css能干的事情，尽量不要用JavaScript来干。毕竟JavaScript的解析执行过于直接和粗暴，而css效率更高。4、尽可能压缩的js文件，减少资源下载的负担5、尽可能避免在js中逐条操作dom样式，尽可能预定义好css样式，然后通过改变样式名来修改dom样式，这样集中式的操作能减少reflow或repaint的次数。6、尽可能少的在js中创建dom，而是预先埋到HTML中用display:none来隐藏，在js中按需调用，减少js对dom的暴力操作。 3.对于HTML： 1、避免再HTML中直接写css代码。2、使用Viewport加速页面的渲染。3、使用语义化标签，减少css的代码，增加可读性和SEO。4、减少标签的使用，dom解析是一个大量遍历的过程，减少无必要的标签，能降低遍历的次数。5、避免src、href等的值为空。6、减少dns查询的次数。 总结一下：运维人员需要处理页面缓存、cdn及keep-alive引起的连接池占用等问题；后端人员需要处理代码逻辑、缓存、传输优化、报错等问题；前段人员需要做好前端性能优化和配合运维、后端做好借口调试，缓存处理等问题。所以无论是前端、后台、运维都应该很清楚整个流程中的每一步，才能在配合时，得心应手，才能在出现问题时，快速准确的定位问题解决问题，才能在需要优化时，迅速完整的给出方案。本篇文章到这里就结束了， 参考文章链接：https://juejin.im/post/5bbaa549e51d450e827b6b13","categories":[{"name":"面试题","slug":"面试题","permalink":"https://bolianglll.github.io/categories/面试题/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"https://bolianglll.github.io/tags/面试题/"},{"name":"网络通识","slug":"网络通识","permalink":"https://bolianglll.github.io/tags/网络通识/"},{"name":"tcp三次握手","slug":"tcp三次握手","permalink":"https://bolianglll.github.io/tags/tcp三次握手/"},{"name":"http","slug":"http","permalink":"https://bolianglll.github.io/tags/http/"}]},{"title":"成长的点点滴滴基础","slug":"成长的点点滴滴基础","date":"2018-12-20T02:19:41.000Z","updated":"2018-12-27T07:08:40.852Z","comments":true,"path":"2018/12/20/成长的点点滴滴基础/","link":"","permalink":"https://bolianglll.github.io/2018/12/20/成长的点点滴滴基础/","excerpt":"","text":"最近写多了vue的项目， 之前的JS和CSS和其它知识用的比较少了。 下面的知识是方便回忆的~~~~没啥事记下笔记 JS标准库：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/assign(这个博主里面还有很多学习资料提供) 2018 啊里的面试题。个人觉得，偶尔看看面试题，不是为了去面试，而是看下面试题，去了解一下深层的概念和知识.https://blog.csdn.net/Carrie_zzz/article/details/80201131 get和Post区别数据传输：get post的区别重点：GET把参数包含在URL中（数据比较少），POST通过request body传递参数。get的话 就是能获取数据， 但是不能保存。 就是表单那些不能保存Post的话 可以获取数据也能保存。 另外：GET请求在URL中传送的参数是有长度限制的，而POST么有。GET请求只能进行url编码，而POST支持多种编码方式 判断一个变量类型是数组还是对象1.通过length属性：一般情况下对象没有length属性值，其值为undefiend，而数组的length值为number类型 缺点：非常不实用，当对象的属性存在length，且其值为number（比如类数组），则该方法失效，不建议使用，看看即可。2.通过instanceof来判断区分12345678var arr = [1, 2, 3]; var obj = &#123; name: &apos;lyl&apos;, age: 18, 1: &apos;name&apos; &#125; console.log(arr instanceof Array); //true console.log(obj instanceof Array); //false 3.通过constructor12345678var arr = [1, 2, 3]; var obj = &#123; name: &apos;lyl&apos;, age: 18, 1: &apos;name&apos; &#125; console.log(arr.constructor === Array); //true console.log(obj.constructor === Array); //false 通过toString()方法，数组原型和对象原型定义的toString()方法不同-可以判断任何类型12345678 var arr = [1, 2, 3];var obj = &#123; name: &apos;lyl&apos;, age: 18, 1: &apos;name&apos;&#125;console.log(Object.prototype.toString.call(arr) === &apos;[object Array]&apos;); //trueconsole.log(Object.prototype.toString.call(boj) === &apos;[object Array]&apos;); //false 5.随便找一个数组仅有的方法，来判断数组和对象谁有该方法即可（样例以sort来举例）123456789 var arr = [1, 2, 3];var obj = &#123; name: &apos;lyl&apos;, age: 18, 1: &apos;name&apos;&#125; console.log(arr.sort === Array.prototype.sort); //trueconsole.log(obj.sort === Array.prototype.sort); //false 总结：方法应用权重： 优先使用方四toString，因为该方法几乎无缺陷。 次之可以使用方二instanceof和方三constructor 剩下的方法玩玩即可，不实用 js === 和==的区别== 用于比较 判断 两者相等 ==在比较的时候可以转自动换数据类型===用于严格比较 判断两者严格相等 ===严格比较，不会进行自动转换==会进行隐式类型转换总之： “==” 只要求值相等; “===” 要求值和类型都相等 display中 block 和 inline 和 inline-block区别display:blockblock元素会独占一行，多个block元素会各自新起一行。默认情况下，block元素宽度自动填满其父元素宽度。block元素可以设置width,height属性。块级元素即使设置了宽度,仍然是独占一行。block元素可以设置margin和padding属性。 display:inlineinline元素不会独占一行，多个相邻的行内元素会排列在同一行里，直到一行排列不下，才会新换一行，其宽度随元素的内容而变化。inline元素设置width,height属性无效。inline元素的margin和padding属性，水平方向的padding-left, padding-right, margin-left, margin-right都产生边距效果；但竖直方向的padding-top, padding-bottom, margin-top, margin-bottom不会产生边距效果。 display:inline-block简单来说就是将对象呈现为inline对象，但是对象的内容作为block对象呈现。之后的内联对象会被排列在同一行内。比如我们可以给一个link（a元素）inline-block属性值，使其既具有block的宽度高度特性又具有inline的同行特性。 Object.assign()方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。–常用Object.assign(target, …sources) target 目标对象。sources 源对象。1234567891011121314const object1 = &#123; a: 1, b: 2, c: 3&#125;;const object2 = Object.assign(&#123;c: 4, d: 5&#125;, object1);console.log(object2.c, object2.d);下面的写法是错的。 因为...item运算符不能添加进Object.assign.会看做是空。所以穿item return this.mallData.mhPicsListStr.map(item =&gt; &#123; return Object.assign(&#123;&#125;, ...item, &#123; picsAdd: this.ip+item.picsAdd &#125;); &#125;);// expected output: 3 5 功能：1.合并对象 2.合并具有相同属性的对象…还有很多该方法属于浅拷贝，当sources源对象发生变化时。新的object中的值也会改变 Object.prototype.toString(). 检测数据的数据类型。最好用，最规范的123456789var toString = Object.prototype.toString;toString.call(new Date); // [object Date]toString.call(new String); // [object String]toString.call(Math); // [object Math]//Since JavaScript 1.8.5toString.call(undefined); // [object Undefined]toString.call(null); // [object Null] 123var isArray = function (obj) &#123; // 判断对象是否是数组的标准方法 return Object.prototype.toString.call(obj) === &quot;[object Array]&quot;;&#125;; 返回的值是[object 类型] Obj.hasOwnProperty() 方法会返回一个布尔值，指示对象自身属性中是否具有指定的属性prop 要检测的属性 字符串 名称或者 Symbol。本人常用的是用来检测 prop1234567891011o = new Object();o.prop = &apos;exists&apos;;function changeO() &#123; o.newprop = o.prop; delete o.prop;&#125;o.hasOwnProperty(&apos;prop&apos;); // 返回 truechangeO();o.hasOwnProperty(&apos;prop&apos;); // 返回 false 注意JavaScript 并没有保护 hasOwnProperty 属性名，因此某个对象是有可能存在使用这个属性名的属性，使用外部的 hasOwnProperty 获得正确的结果是需要的： 把数组降维简单的：123var res = arr.reduce((beginList,item)=&gt;&#123; return beginList.concat(item)&#125;,[]) 但是对于var arr = [1, 2, [3, 4, [5]]]。这样的话。需要用递归方法或者reduce()123456789101112131415161718递归var recursion=function(arr)&#123; var len=arr.length,newarr=[]; for(var i=0;i&lt;len;i++)&#123; if(Array.isArray(arr[i])) newarr.push.apply(newarr,recursion(arr[i])) else newarr.push(arr[i]) &#125; return newarr&#125;更好的方法：reducelet flatten = arr =&gt; arr.reduce((begin,current)=&gt;&#123; Array.isArray(current)? begin.push(...flatten(current)): begin.push(current); return begin &#125;,[]) 找出数组中出现的次数超过一半以上的选项123456789101112131415161718192021222324function getItem(arr = []) &#123; const half = Math.floor(arr.length / 2) let result = [] let m = new Map() arr.map(item =&gt; &#123; m.has(item) ? m.set(item, m.get(item) + 1) : m.set(item, 1) if (m.get(item) &gt;= half) &#123; !result.includes(item) &amp;&amp; result.push(item) &#125; &#125;) return result.length ? result : 0 &#125;本人list.reduce((beginList, item) =&gt; &#123;if (item in beginList) &#123;beginList[item] ++;&#125;else &#123;beginList[item] = 1;&#125;return beginList;&#125;, &#123;&#125;);先求出数组的所有内容出现的次数。 然后再循环一次看那个长度超出一半。 []==![] 结果返回来true==发生js隐式转换。对于JS隐式转换的解释方案。https://juejin.im/post/5bc5c752f265da0a9a399a62 数组去重最简单的就是ES6的语法 new Set();12345aca=[&apos;66&apos;,&apos;88&apos;,undefined,NaN,undefined,NaN]let bbg = new Set(aca)//Set(4) &#123;&quot;66&quot;, &quot;88&quot;, undefined, NaN&#125;Array.from(bbg)//(4) [&quot;66&quot;, &quot;88&quot;, undefined, NaN] 1234567891011121314151617181920212223-------------------------对象属性去重function unique(arr)&#123; var res =[]; var json = &#123;&#125;; for(var i=0;i&lt;arr.length;i++)&#123; if(!json[arr[i]])&#123; res.push(arr[i]); json[arr[i]] = 1; &#125; &#125; return res;&#125;-----------------------reduce---arr3 = aa =&gt;aa.reduce((begin,items)=&gt;&#123;if(begin.includes(items))&#123;begin.push(items)&#125;return begin&#125;,[])封装诚一个函数 上面indexOf 只能对于字符串有效果。 对于一些数组里面有underfined Object类型的。 indexOf 数组去重不了.所以要用ES6的数组新语法。 includes();123456bb=[undefined,&#123;&#125;,&#123;&#125;,Object,undefined]bb.forEach(item =&gt;&#123;if(!eray1.includes(item))&#123;eray1.push(item)&#125;&#125;) 但是对于{} 。 includes({})会返回来false.也无法处理。 {}==={}也是会返回来false。处理方式的话 Object.prototype.toString.call({})。做特殊处理。 一般来讲的话。 includes已经够用了 不用ES6的语法解决12345678910111213141516171819 function (arr1=[])&#123; var result = []; var flag = true; //控制NaN for(var i=0;i&lt;arr1.length;i++)&#123; if(result.indexOf(arr1[i])==-1)&#123; if(this[i]!=this.[i]) //因为IndexOf监控不了NaN值。 需要做一层处理 includes()可以。体验ES6的好处 &#123; if(flag)&#123; result.push(arr1[i]); flag = false &#125; &#125; else&#123; result.push(arr1[i]); &#125; &#125; &#125; return result;&#125; 12345678用过滤器去解决 性能更好&apos;use strict&apos;; var r,arr = [&apos;apple&apos;, &apos;strawberry&apos;, &apos;banana&apos;, &apos;pear&apos;, &apos;apple&apos;, &apos;orange&apos;, &apos;orange&apos;, &apos;strawberry&apos;]; r = arr.filter(function (element, index, self) &#123; return self.indexOf(element) === index; &#125;);console.log(r.toString()); 小牛第四年会变老，老牛一年生一条小牛。然后第一年买了一条小牛。求N年后多少条1234567891011121314151617181920/** *自己的答案 *@param &#123;Array&#125; origin -源车间 *@param &#123;Number&#125; n 年数*/function getOrigin(origin,n)&#123; const createCatle = cattle =&gt;&#123; cattle.age++; cattle.age &gt;=4&amp;&amp; origin.push(&#123;age:1&#125;) &#125; for(let i=0;i&lt;n;i++)&#123; origin.forEach(item=&gt;createCatle(item)) &#125;&#125;let origin = [&#123;age:1&#125;]getOrigin(origin,9)总数等于 origin.length网上答案： 斐波那契数列算法 封装一个函数，参数是定时器的时间，.then执行回调函数1234567891011function setTimeGo(times)&#123;return new Promise((resolve,reject)=&gt;&#123; setTimeout(()=&gt;&#123; resolve();&#125;,times)&#125;)&#125;setTimeGo(2000).then(res=&gt;&#123; console.log(&apos;lblblbl&apos;)&#125;)//setTimeout是没有回调then的功能。 需要借助new Promise。去实现.then的回调函数 .js 实现 ajax 请求或者submit请求时 锁屏功能以及开锁功能（请求时界面Loading以及元素不能点击，请求完成即消除Loading）1234567891011121314151617function(url, fn) &#123; var obj = new XMLHttpRequest(); // XMLHttpRequest对象用于在后台与服务器交换数据 obj.open(&apos;GET&apos;, url, true); obj.onreadystatechange= function() &#123; if(obj.readyState == 4 &amp;&amp; obj.status == 200||obj.status == 304) &#123; loading.style.display = &quot;none&quot; &#125; else &#123; alert(&quot;不能点击,哈哈哈!&quot;); &#125; &#125;;obj.send(null);&#125; 检验对象里面包不包含某个字段 res.hasOwnProperty(‘checkboxState’). indexOf检测数组还有字符串。不能检测字符串注意： indexOf是不能检测对象的。 所以不要看经常用就啥用。对于某些同学们 IndexOf 只能检测部分数组1234567891011121314gg=[&apos;a&apos;,&apos;b&apos;]console.log(gg.indexOf(&apos;a&apos;)&gt;&gt;&gt;&gt;&gt;&gt;0)pp=[&#123;a:22&#125;,&#123;b:33&#125;]console.log(pp.indexOf(&apos;a) &gt;&gt;&gt;&gt;&gt;&gt;-1)除此之外。对象const ee = &quot;gg&quot;pp=&#123;aa:66,cc:&apos;89&apos;&#125;pp[&apos;aa&apos;]&gt;&gt;&gt;&gt;66.pp[ee] = 100pp[&apos;gg&apos;]&gt;&gt;&gt;&gt;&gt;99数组：pp[0] = [].对于数组的话。 下标要为数字 overflow: auto 对于一些内容自适应高度的隐藏折叠非常好用。 点击隐藏和显示。overflow: scroll将隐藏所有溢出的内容并使滚动条出现在相关元素上。如果内容没有溢出，滚动条仍然可见，但被禁用。overflow: auto 非常相似，但滚动条仅在内容溢出时出现。 axios 的缺点（ajax,axios,fetch区别）1.JQ的ajax 12345678 $.ajax(&#123; type: &apos;POST&apos;, url: url, data: data, dataType: dataType, success: function () &#123;&#125;, error: function () &#123;&#125;&#125;); 优缺点：本身是针对MVC的编程,不符合现在前端MVVM的浪潮基于原生的XHR开发，XHR本身的架构不清晰，已经有了fetch的替代方案JQuery整个项目太大，单纯使用ajax却要引入整个JQuery非常的不合理（采取个性化打包的方案又不能享受CDN服务）优点的话：兼容IE的老版本。 axios1234567891011121314axios(&#123; method: &apos;post&apos;, url: &apos;/user/12345&apos;, data: &#123; firstName: &apos;Fred&apos;, lastName: &apos;Flintstone&apos; &#125;&#125;).then(function (response) &#123; console.log(response);&#125;).catch(function (error) &#123; console.log(error);&#125;); 优缺点：从 node.js 创建 http 请求支持 Promise API客户端支持防止CSRF提供了一些并发请求的接口（重要，方便了很多的操作） fetch1234567try &#123; let response = await fetch(url); let data = response.json(); console.log(data);&#125; catch(e) &#123; console.log(&quot;Oops, error&quot;, e);&#125; 优点：符合关注分离，没有将输入、输出和用事件来跟踪的状态混杂在一个对象里更好更方便的写法更加底层，提供的API丰富（request, response）脱离了XHR，是ES规范里新的实现方式缺点1）fetchtch只对网络请求报错，对400，500都当做成功的请求，需要封装去处理2）fetch默认不会带cookie，需要添加配置项3）fetch不支持abort，不支持超时控制，使用setTimeout及Promise.reject的实现的超时控制并不能阻止请求过程继续在后台运行，造成了量的浪费4）fetch没有办法原生监测请求的进度，而XHR可以 为什么要用axiosaxios 是一个基于Promise 用于浏览器和 nodejs 的 HTTP 客户端，它本身具有以下特征： 从浏览器中创建 XMLHttpRequest从 node.js 发出 http 请求支持 Promise API拦截请求和响应转换请求和响应数据取消请求动转换JSON数据客户端支持防止CSRF/XSRF（一些跨域浏览器的伪造请求） 比较安全 如果真的要说缺点他们浏览器支持有问题。 因为它只支持ie8+以上的。 老版本IE不支持 什么是跨域，以及解决跨域的实现方式有这样一个URL：http://item.taobao.com/item.htm?a=1&amp;b=2&amp;c=&amp;d=xxx&amp;e，请写一段JS程序提取URL中的各个GET参数(参数名和参数个数不确定)，将其按key-value形式返回到一个json结构中，如{a:&#39;1&#39;, b:’2’, c:’’, d:’xxx’, e:undefined}。一开始自己写的答案1234567891011121314function getKeyValue(url)&#123;const params=&#123;&#125;;if(url.indexOf(&apos;?&apos;)==-1) returnconst urlString = url.substring(url.indexOf(&apos;?&apos;)+1);urlString.split(&apos;&amp;&apos;).forEach((item)=&gt;&#123; if(item.indexOf(&apos;=&apos;)&gt;-1)&#123; let itemParams = item.split(&apos;=&apos;); params[itemParams[0]] = itemParams[1]&#125;else&#123; params[item] = &apos;underfined&apos;&#125;&#125;)return params&#125; 后面发现 其实split的话。 还是可以优化的。 因为就是就算split判断等号。获得一个数组。就算没有等号。 我赋值一个itemParams[1]。 不存在的话也会为underfined。12345678910function getKeyValue(url)&#123;const params=&#123;&#125;;if(url.indexOf(&apos;?&apos;)==-1) returnconst urlString = url.substring(url.indexOf(&apos;?&apos;)+1);urlString.split(&apos;&amp;&apos;).forEach((item)=&gt;&#123; let itemParams = item.split(&apos;=&apos;); params[itemParams[0]] = itemParams[1]&#125;)return params&#125; 升级版对于一些如果参数是同名的话。 把他们放在同一个数组里面12345678910111213141516function getMoreKeyValue(url)&#123; const params = &#123;&#125;;if(url.indexOf(&apos;?&apos;)==-1) returnconst urlString = url.substring(url.indexOf(&apos;?&apos;)+1);urlString.split(&apos;&amp;&apos;).forEach(item=&gt;&#123; let itemParams = item.split(&apos;=&apos;); if(params.hasOwnProperty(itemParams[0]))&#123; params[itemParams[0]]=Array.isArray(itemParams[0])?params[itemParams[0]].push(itemParams[1]) :[params[itemParams[0]],itemParams[1]]&#125;else&#123;params[itemParams[0]] = itemParams[1]&#125;&#125;)return params&#125;url = &apos;http://item.taobao.com/item.html?a=1&amp;b=2&amp;c=&amp;d=xxx&amp;e&amp;a=2&apos;;getMoreKeyValue(url) &gt;&gt;&gt;&gt;c &#123; a: [ &apos;1&apos;, &apos;2&apos; ], b: &apos;2&apos;, c: &apos;&apos;, d: &apos;xxx&apos;, e: undefined &#125; 经常问的红绿灯问题简单版本123456789101112131415161718192021setTimeout(changered,0); /*设置最开始时间间隔为0*/ function changered()&#123; var div=document.getElementById(&quot;div1&quot;); div.style.backgroundColor=&quot;red&quot;; console.log(&apos;红&apos;) setTimeout(changeyellow,7000);/*红灯持续亮7秒*/ &#125; function changeyellow()&#123; var div=document.getElementById(&quot;div1&quot;); div.style.backgroundColor=&quot;yellow&quot;; console.log(&apos;黄&apos;) setTimeout(changegreen,3000); &#125; function changegreen()&#123; console.log(&apos;绿&apos;) var div=document.getElementById(&quot;div1&quot;); div.style.backgroundColor=&quot;green&quot;; setTimeout(changered,5000); &#125; 对于一些需要要.then函数去做红绿等的方法12345678910111213141516171819//创建一个打印的函数function light(data)&#123; console.log(data)&#125;//封装一个setTimeout的函数function getSetTimeOut(time)&#123; return new Promise((resolve,reject)=&gt;&#123; setTimeout(()=&gt;&#123; resolve() &#125;,time) &#125;)&#125;//执行红绿灯函数async function begin()&#123;await getSetTimeOut(7000).then(console.log(&apos;红&apos;))await getSetTimeOut(5000).then(console.log(&apos;黄&apos;))await getSetTimeOut(3000).then(console.log(&apos;绿&apos;))begin()&#125; 两个数组做比较。 当有一个相等的话。 跳出循环。运行次数最少-自己项目的做法123456789101112131415161718192021222324252627282930array2 = [&apos;66&apos;,&apos;77,&apos;,&apos;99&apos;];array = [&apos;55&apos;,&apos;66&apos;,&apos;555&apos;,&apos;44&apos;];for(let i = 0;i&lt;array2.length;i++)&#123; bol = array.some(item=&gt;&#123; console.log(&apos;22&apos;); return item===array2[i]&#125;) if(bol) break;&#125;一个数字和数组做比较bol = array.some(item=&gt;&#123;console.log(22)return item===b&#125;)this.bankNbr = res.BANK_NBR; this.subBranchList = res.subBranchList; if (this.bankNbr != &apos;&apos;) &#123; this.isMatchSales = this.salesBranch.some(item =&gt; &#123; return item.brano === this.bankNbr; &#125;); &#125; else &#123; for (let i = 0; i &lt; this.subBranchList.length; i++) &#123; this.isMatchSales = this.salesBranch.some(item =&gt; &#123; return item.brano === this.subBranchList[i].subBranchNo; &#125;); if (this.isMatchSales) break; &#125; &#125; 减少对于for循环的使用。 用ES6的语法 find()。 取代for循环啊 find()。数组实例的方法。参数是一个回调函数。所有数组依次执行回调函数，直到找出一个返回值为true的成员。然后返回该成员。如果没有符合条件的成员，返回underfined.优化123const matchitem = this.subBranchList.find(sub =&gt;this.salesBranch.some(item =&gt; &#123;item.brano === usb.subBranchNo;&#125;););一行解决this.isMatchSales = !!matchitem //转义成boolean类型 !underfined =true !!=false 返回来item的话。就会这样Object.is(NAN,value) //查看数据类型为NAN的。 用find 用find的话 如果Item返回来是空字符类型的话，!!也会转化为false。 对于有空类型的话’’。用findIndex()比较好，返回来index索引.再去转boolean 比较好。对于find和findindex 当item返回来true的时候，都会跳出循环12const matchitem = this.subBranchList.findIndex(sub =&gt;this.salesBranch.some(item =&gt; &#123;item.brano === usb.subBranchNo;&#125;););一行解决this.isMatchSales = matchitem !==-1 //转义成boolean类型 findIndex相当于indexOf类似。 找不到的话， 会返回来索引-1 对于数组的相邻去重。 还有相邻相加- 同事出题123456789101112131415数组相邻去重bb = &apos;AAAAAAbbbbbbaaaaacccc&apos;bgg=[&apos;1&apos;,&apos;2&apos;,&apos;2&apos;,&apos;3&apos;,&apos;2&apos;] function getArray(params)&#123; const result = []; for(let i=0;i&lt;params.length;i++)&#123; if(i==0 ||params[i-1] !==params[i])&#123; result.push(params[i]) &#125; &#125; return result &#125;console.log(getArray(bb)) //[&quot;A&quot;, &quot;b&quot;, &quot;a&quot;, &quot;c&quot;]console.log(getArray(bgg)) //[&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;2&quot;] 123456789101112131415数组相邻相加bg=[&apos;1&apos;,&apos;4&apos;,&apos;4&apos;,&apos;4&apos;,&apos;2&apos;,&apos;3&apos;,&apos;3&apos;]function getArray2(params)&#123; const result = []; for(let i=0;i&lt;params.length;i++)&#123; if(params[i-1] !==params[i])&#123; result.push(params[i]) &#125;else if(params[i-1] ===params[i])&#123; const len = result.length; result[len-1] = (Number(result[len-1])+Number(params[i])).toString(); &#125; &#125; return result &#125;console.log(getArray2(bg)) //[&quot;1&quot;, &quot;12&quot;, &quot;2&quot;, &quot;6&quot;] bb=’aAbCdE’ 打印 “A-Aa-Bbb-Cccc-Ddddd-Eeeeee”123456789101112131415161718192021222324252627282930自己的思路function getArr2(strs)&#123;let allStr = &apos;&apos;; const creatDo = (case1,n)=&gt;&#123; let casestr1=&apos;&apos;; casestr1 = case1.toUpperCase()+case1.toLowerCase().repeat(n); return casestr1&#125;for(let j=0;j&lt;strs.length;j++)&#123;allStr = j==0?creatDo(strs[j],j):allStr+&apos;-&apos;+creatDo(strs[j],j);&#125;return allStr;&#125;ES7function func4(str) &#123; return str .split(&apos;&apos;) .map((en, i) =&gt; en.toUpperCase().padEnd(i + 1, en.toLowerCase())) //获得一个新数组。.padEnd(n,test) 代表在后面加N个test .join(&apos;-&apos;) //数组的并接&#125;ES6function fun5(str)&#123; return str .split(&apos;&apos;) .map((item,i)=&gt;`$&#123;item.toUpperCase()&#125;$&#123;item.toLowerCase().repeat(i)&#125;`) .join(&apos;-&apos;)&#125; 传入10 求出10里面（不包括10） 3 5 倍数相加之和 例如 3 6 9 5（3的倍数）（5的倍数） 3+6+9+5 = 23其实用循环是不可以的。所以啊 等差数列求和 等差求和算法 直接运算123456789function totol(nums)&#123; let sum=0; for(let i=0;i&lt;nums;i++)&#123; if(i%3==0||i%5==0)&#123; sum +=i; &#125; &#125; return sum;&#125; 1234567891011121314151617自己写的function totol(nums)&#123;let sum=0;let threeCount=1;let fiveCount=1; for(let i=3;i&lt;nums;i=3*threeCount)&#123; sum+=i; ++threeCount;console.log(threeCount) console.log(i) &#125;for(let j=5;j&lt;nums;j=5*fiveCount)&#123; sum+=j; fiveCount++;&#125;return sum&#125; 123456789优化后function fucc(num)&#123; let result = 0; for(let i=1;i*3&lt;num;i++)&#123; if(i*5&lt;num) result +=i*5 result +=i*3 &#125; return result;&#125; 判断回文数利用数组反序号123function isPalindrome(str)&#123; return str.split(&apos;&apos;).reverse().join(&apos;&apos;) ===str&#125;","categories":[],"tags":[]},{"title":"JS回收垃圾机制了解","slug":"JS回收垃圾机制了解","date":"2018-12-19T04:50:01.044Z","updated":"2018-12-19T05:00:15.728Z","comments":true,"path":"2018/12/19/JS回收垃圾机制了解/","link":"","permalink":"https://bolianglll.github.io/2018/12/19/JS回收垃圾机制了解/","excerpt":"","text":"参考：https://blog.csdn.net/qq_21325977/article/details/79973761最近有同事问我了解关于JS的回收机制不，发现自己没多懂。 所以在网上看了一下介绍。 希望能帮到你们。 我觉的， 了解就好。 不用硬记，这个我们实际开发用的比较少 了解一下 js 的垃圾回收机制原理：垃圾收集器会定期（周期性）找出那些不在继续使用的变量，然后释放其内存。 （1）标记清除法在函数声明一个变量的时候，就将这个变量标记为“进入环境”。从逻辑上讲，永远都不能释放进入环境的变量作占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。而当变量离开环境时，则将其标记为“离开环境”。垃圾回收器在运行时候会给存储在内存中中的所有变量都加上标记。然后它会去掉环境中的变量以及被环境中的变量引用的变量的标记（闭包）。在此之后再被标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后，垃圾回收器完成内存清楚工作，销毁那些带标记的值并回收他们所占用的内存空间123456functiontest()&#123; var a = 10 ; //被标记 ，进入环境 var b = 20 ; //被标记 ，进入环境 &#125; test(); //执行完毕 之后 a、b又被标离开环境，被回收 （2）引用计数法引用计数的含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是1。如果同一个值又被赋给另一个变量，则该值的引用次数加1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数减1。当这个值的引用次数变成0时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。这样，当垃圾回收器下次再运行时，它就会释放那些引用次数为0的值所占用的内存。 **但是很重要的一点是当遇到循环引用的时候，函数的引用次数就不会为0，所以不会被垃圾回收器回收内存，会造成内存泄露。在IE中涉及COM对象，就会存在循环引用的问题** 123456functiontest()&#123; var a = &#123;&#125; ; //a的引用次数为0 var b = a ; //a的引用次数加1，为1 var c =a; //a的引用次数再加1，为2 var b =&#123;&#125;; //a的引用次数减1，为1 对于内存泄露什么情况会引起内存泄漏？虽然有垃圾回收机制但是我们编写代码操作不当还是会造成内存泄漏。 意外的全局变量引起的内存泄漏。 原因：全局变量，不会被回收。解决：使用严格模式避免。 闭包引起的内存泄漏 原因：闭包可以维持函数内局部变量，使其得不到释放。解决：将事件处理函数定义在外部，解除闭包,或者在定义事件处理函数的外部函数中，删除对dom的引用。 没有清理的DOM元素引用 原因：虽然别的地方删除了，但是对象中还存在对dom的引用解决：手动删除。 被遗忘的定时器或者回调 原因：定时器中有dom的引用，即使dom删除了，但是定时器还在，所以内存中还是有这个dom。解决：手动删除定时器和dom。 子元素存在引用引起的内存泄漏 原因：div中的ul li 得到这个div，会间接引用某个得到的li，那么此时因为div间接引用li，即使li被清空，也还是在内存中，并且只要li不被删除，他的父元素都不会被删除。解决：手动删除清空","categories":[],"tags":[]},{"title":"深入了解Vuex原理","slug":"深入了解Vuex原理","date":"2018-12-12T16:00:00.000Z","updated":"2018-12-14T02:00:03.648Z","comments":true,"path":"2018/12/13/深入了解Vuex原理/","link":"","permalink":"https://bolianglll.github.io/2018/12/13/深入了解Vuex原理/","excerpt":"","text":"最近有个同事问了我很多关于vuex的原理和知识。 突然发现，好像最近做公司的项目，（项目原因，要自己在vue中封一个方法。例如localStorage.或者sessiontStorage） 好久没用vuex了。 都是用公司大佬封装的存储数据的方法~~~~。但是对于我们这些刚刚出去工作的人，或者在一些Vue项目的公司工作的话。 理解vuex原理是必不可少的。 那么接下来 想着分享vuex的原理。顺便帮自己复习一下。 转载：https://vuex.vuejs.org/zh/guide/ —vuex官网。如果你们觉的看官网更容易理解。 可以看官网。 我是按照自己更容易理解的方法。根据VUEX做一次笔记。 欢迎给意见。 介绍VUEXVuex是Vue.js应用程序的状态管理模式+库.它充当应用程序中所有组件的集中存储，其规则确保state只能以可预测的方式进行变更。它还与Vue的官方devtools扩展集成，以提供零配置时间旅行调试和状态快照导出/导入等高级功能。 State状态，这是真理，推动我们的应用程序的来源;View视图，这是仅仅一个声明性映射状态 ;Actions动作是状态可能因视图中的用户输入而改变的方式。 为什么要用vuex呢？Vue 属于一个单向数据流的程序。 -简单性但是，当我们有多个共享共同状态的组件时。 这种简单性就会崩溃 多个视图可能取决于同一个状态。不同观点的Actions可能需要改变同一个state。 对于问题一，对于深层嵌套组件，传递Data可能很乏味，而且对于兄弟组件根本不起作用。对于问题二，我们经常发现自己采用解决方案，例如到达直接父/子实例引用或尝试通过事件变异和同步状态的多个副本。这两种模式都很脆弱，很快导致无法维护的代码。 所以这个时候，就需要引入到了VUEX,从组件中提供共享的state（状态）。而且在全局中去管理他们。 有了这个。 才可以让组件树变成一个更大的视图。任何组件都可以访问state状态或者触发动作Actions。无论他们在哪个树原理图.Devtools属于Vue官方扩展集成的工具 Vuex核心State Getters Mutations Actions Modules VUEX入门 123456789101112131415161718192021222324252627282930313233343536373839404142//安装vuexnpm install vuex --save//在自己的src创建一个store目录。创建文件 index.js .然后引入Vueximport Vue from &apos;vue&apos;import Vuex from &apos;vuex&apos;Vue.use(Vuex)export default new Vuex.Store(&#123; state:&#123; city:&apos;上海&apos; &#125;, actions:&#123; changePatch(ctx,city)&#123; ctx.changeCity(&apos;city&apos;) &#125; &#125;, mutations:&#123; changeCity(state,city)&#123; state.city = city; &#125; &#125;&#125;)//在main.js引用import store from &apos;./store&apos;new Vue(&#123; el: &apos;#app&apos;, store,&#125;)// 在组件里面引用---最直接的引用 &lt;div class=&quot;button&quot;&gt;&#123;&#123;this.$store.state.city&#125;&#125;&lt;/div&gt;//对于上图的引用 vuex里面主要是通过state actions mutations来操作流程的。//当组件想修改state的数据的话。 mutations是唯一的方式。 所以要通过dispatch去修改actions。 再通过actions去修改Mutations。mutations再去修改state的值。 从而改变各个组件依赖这个state的值vue&lt;div class=&quot;button&quot; @click=&quot;handleCityChange(item.name)&quot;&gt;&#123;item.name&#125;&#125;&lt;/div&gt;JS handleCityChange(cityName)&#123; this.$store.dispatch(&apos;changePatch&apos;,cityName) &#125; store.js 如上方 其实上方的图是对于VUEX最原始的用法。但是 我们我们组件里传递的数据。 如果不是异步的话。 我们是可以直接去改变mutations。去修改的state的值。 一样是可以的 VUEX应用的核心是store库Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。 你不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。","categories":[],"tags":[]},{"title":"localStorage、sessionStorage、Cookie的区别及用法","slug":"localStorage、sessionStorage、Cookie的区别及用法","date":"2018-12-12T16:00:00.000Z","updated":"2018-12-13T04:43:51.845Z","comments":true,"path":"2018/12/13/localStorage、sessionStorage、Cookie的区别及用法/","link":"","permalink":"https://bolianglll.github.io/2018/12/13/localStorage、sessionStorage、Cookie的区别及用法/","excerpt":"","text":"由于在公司做vue项目。 不用vuex去存储数据。 都是基于localStorage、sessionStorage去封装的方法。 所以在网上去了解了一下他们的用法。和优势处。提升下自己项目经验 转载：https://segmentfault.com/a/1190000012057010 共同点：localStorage、sessionStorage、Cookie共同点：都是保存在浏览器端，且同源的 webstoragewebstorage是本地存储，存储在客户端，包括localStorage和sessionStorage。 localStoragelocalStorage生命周期是永久，这意味着除非用户显示在浏览器提供的UI上清除localStorage信息，否则这些信息将永远存在。存放数据大小为一般为5MB,而且它仅在客户端（即浏览器）中保存，不参与和服务器的通信。 localStorage的优势1、localStorage拓展了cookie的4K限制 2、localStorage会可以将第一次请求的数据直接存储到本地，这个相当于一个5M大小的针对于前端页面的数据库，相比于cookie可以节约带宽，但是这个却是只有在高版本的浏览器中才支持的 sessionStoragesessionStorage仅在当前会话下有效，关闭页面或浏览器后被清除。存放数据大小为一般为5MB,而且它仅在客户端（即浏览器）中保存，不参与和服务器的通信。源生接口可以接受，亦可再次封装来对Object和Array有更好的支持。 localStorage和sessionStorage使用时使用相同的API：1234567localStorage.setItem(&quot;key&quot;,&quot;value&quot;);//以“key”为名称存储一个值“value”localStorage.getItem(&quot;key&quot;);//获取名称为“key”的值localStorage.removeItem(&quot;key&quot;);//删除名称为“key”的信息。localStorage.clear();​//清空localStorage中所有信息 简单的举个例子来了解一下他们的用法仿一下京东官网顶部的广告关闭，效果为第一次进入官网会出现广告，然后点击关闭，刷新网页不会再显示广告，但是当清除localStorage存入的数据，刷新网页会再显示广告1234567891011121314151617181920212223&lt;div class=&quot;header&quot;&gt; &lt;div class=&quot;header-a&quot;&gt; &lt;a href=&quot;&quot;&gt;&lt;/a&gt; &lt;i class=&quot;close&quot;&gt;x&lt;/i&gt; &lt;/div&gt;&lt;/div&gt; &lt;script src=&quot;../js/jquery.min.js&quot;&gt;&lt;/script&gt;function haxi()&#123; //判断localStorage里有没有isClose if(localStorage.getItem(&quot;isClose&quot;))&#123; $(&quot;.header&quot;).hide(); &#125;else&#123; $(&quot;.header&quot;).show(); &#125; //点击关闭隐藏图片存取数据 $(&quot;.close&quot;).click(function()&#123; $(&quot;.header&quot;).fadeOut(1000); localStorage.setItem(&quot;isClose&quot;, &quot;1&quot;); &#125;) &#125; haxi(); 在项目里。 经常把一些弹框的判断。 存进这里面。 好让客户在选择之后。不再提示。或者从一个页面做出了一个操作之后。 把该页面的数据存进storage。 然后在其它页面。 读取该数据。 起到了一个相当于vuex的存储的效果 作用域不同不同浏览器无法共享localStorage或sessionStorage中的信息。相同浏览器的不同页面间可以共享相同的 localStorage（页面属于相同域名和端口），但是不同页面或标签页间无法共享sessionStorage的信息。这里需要注意的是，页面及标 签页仅指顶级窗口，如果一个标签页包含多个iframe标签且他们属于同源页面，那么他们之间是可以共享sessionStorage的 cookie生命期为只在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭。 存放数据大小为4K左右 。有个数限制（各浏览器不同），一般不能超过20个。与服务器端通信：每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题。但Cookie需要程序员自己封装，源生的Cookie接口不友好(http://www.jb51.net/article/6...)。用法和LoadStorage一样12345678910111213141516//Cookie方法&lt;script src=&quot;../js/cookie.js&quot;&gt;&lt;/script&gt;//Cookie函数自己封装引入function haxi()&#123; if(getCookie(&quot;isClose&quot;))&#123; $(&quot;.header&quot;).hide(); &#125;else&#123; $(&quot;.header&quot;).show(); &#125; $(&quot;.close&quot;).click(function()&#123; $(&quot;.header&quot;).fadeOut(1000); setCookie(&quot;isClose&quot;, &quot;1&quot;,&quot;s10&quot;); &#125;) &#125; haxi(); cookie的优点：具有极高的扩展性和可用性 1.通过良好的编程，控制保存在cookie中的session对象的大小。2.通过加密和安全传输技术，减少cookie被破解的可能性。3.只有在cookie中存放不敏感的数据，即使被盗取也不会有很大的损失。4.控制cookie的生命期，使之不会永远有效。这样的话偷盗者很可能拿到的就 是一个过期的cookie。 cookie的缺点 1.cookie的长度和数量的限制。每个domain最多只能有20条cookie，每个cookie长度不能超过4KB。否则会被截掉。2.安全性问题。如果cookie被人拦掉了，那个人就可以获取到所有session信息。加密的话也不起什么作用。3.有些状态不可能保存在客户端。例如，为了防止重复提交表单，我们需要在服务端保存一个计数器。若吧计数器保存在客户端，则起不到什么作用。","categories":[],"tags":[]},{"title":"对于制作滚动代码。JS中offsetTop、clientTop、scrollTop各位置属性详解","slug":"JS中offsetTop、clientTop、scrollTop、offsetTop各位置属性详解","date":"2018-12-12T07:31:21.947Z","updated":"2018-12-13T02:51:11.157Z","comments":true,"path":"2018/12/12/JS中offsetTop、clientTop、scrollTop、offsetTop各位置属性详解/","link":"","permalink":"https://bolianglll.github.io/2018/12/12/JS中offsetTop、clientTop、scrollTop、offsetTop各位置属性详解/","excerpt":"","text":"最近在做自己的一个web端项目（XXX）。 然后在制作滚动代码的时候， 发现自己对offsetTop、clientTop、scrollTop、offsetTop忘记的有点多。。。以前可能对这个操作行云流水的。。。哈哈哈，可能是做的公司Vue项目多， 很少用DOM操作。 突然来做一个滚动代码。。。。。所以，还是得温故而知新 转载：https://github.com/pramper/Blog/issues/10 说明offsetTop, offsetLeft：只读属性。要确定的这两个属性的值，首先得确定元素的offsetParent。offsetParent指的是距该元素最近的position不为static的祖先元素，如果没有则指向body元素。确定了offsetParent，offsetLeft指的是元素左侧偏移offsetParent的距离，同理offsetTop指的是上侧偏移的距离。offsetHeight, offsetWidth：只读属性。这两个属性返回的是元素的高度或宽度，包括元素的边框、内边距和滚动条。返回值是一个经过四舍五入的整数。（常用来计算为div的总宽度和总高度） scrollHeight, scrollWidth：只读属性。返回元素内容的整体尺寸，包括元素看不见的部分（需要滚动才能看见的）。返回值包括padding，但不包括margin和border。如下图： scrollHeight：IE、Opera 认为 scrollHeight 是网页内容实际高度，可以小于 clientHeight。FF 认为 scrollHeight 是网页内容高度，不过最小值是 clientHeight。scrollTop, scrollLeft：图中已经表示的很明白了。如果元素不能被滚动，则为0。clientTop：元素上边框的厚度，当没有指定边框厚底时，一般为0window.innerWidth, window.innerHeight：只读。视口（viewport）的尺寸，包含滚动条offsetHeight：获取对象相对于由offsetParent属性指定的父坐标(css定位的元素或body元素)的高度。IE、Opera 认为 offsetHeight = clientHeight + 滚动条 + 边框。FF 认为 offsetHeight 是网页内容实际高度，可以小于 clientHeight。offsetHeight在新版本的FF和IE中是一样的，表示网页的高度，与滚动条无关，chrome中不包括滚动条。clientHeight, clientWidth：包括padding，但不包括border, margin和滚动条。如下图： ———————————————–分隔线———————————————clientX、clientY：相对于浏览器窗口可视区域的X，Y坐标（窗口坐标），可视区域不包括工具栏和滚动条。IE事件和标准事件都定义了这2个属性。-手指移动的touches.clientY-自动这个属性。 可以来做手指滚动 pageX、pageY：类似于event.clientX、event.clientY，但它们使用的是文档坐标而非窗口坐标。这2个属性不是标准属性，但得到了广泛支持。IE事件中没有这2个属性。 offsetX、offsetY：相对于事件源元素（target或srcElement）的X,Y坐标，只有IE事件有这2个属性，标准事件没有对应的属性。 screenX、screenY：相对于用户显示器屏幕左上角的X,Y坐标。标准事件和IE事件都定义了这2个属性 常用的是clientX clientY screenX、screenY","categories":[],"tags":[]},{"title":"Vue.js个人经验总结","slug":"Vue.js个人总结","date":"2018-12-11T08:13:05.771Z","updated":"2018-12-27T04:59:20.063Z","comments":true,"path":"2018/12/11/Vue.js个人总结/","link":"","permalink":"https://bolianglll.github.io/2018/12/11/Vue.js个人总结/","excerpt":"","text":"其实Vue里，在我们开发中，大多数的东西我们都可以在vue.js的官网里找到。但是也有些 在你封指令或者组件时候。有更便捷的方法，或者可以用高级用法来形容。 自定义指令 除了核心功能默认内置的指令 (v-model 和 v-show)，Vue 也允许注册自定义指令。注意，在 Vue2.0 中，代码复用和抽象的主要形式是组件。然而，有的情况下，你仍然需要对普通 DOM 元素进行底层操作，这时候就会用到自定义指令。举个聚焦输入框的例子当页面加载时，该元素将获得焦点 (注意：autofocus 在移动版 Safari 上不工作)。事实上，只要你在打开这个页面后还没点击过任何内容，这个输入框就应当还是处于聚焦状态。现在让我们用指令来实现这个功能12345678// 注册一个全局自定义指令 `v-focus`Vue.directive(&apos;focus&apos;, &#123; // 当被绑定的元素插入到 DOM 中时…… inserted: function (el) &#123; // 聚焦元素 el.focus() &#125;&#125;) 如果想注册局部指令，组件中也接受一个 directives 的选项：12345678directives: &#123; focus: &#123; // 指令的定义 inserted: function (el) &#123; el.focus() &#125; &#125;&#125; 使用 然后你可以在模板中任何元素上使用新的 v-focus 属性，如下：1&lt;input v-focus&gt; 例如 VUX里面也提供了 TransferDom 的自定义指令。 this.$forUpdate() this.$forceUpdate() 处理页面刷新问题（v-for循环值刷新等）问题描述：在使用Vue框架开发时，在函数中改变了页面中的某个值，在函数中查看是修改成功了，但在页面中没有及时刷新改变后的值解决：运用 this.$forceUpdate() 强制刷新（因为数据层次太多，render函数没有自动更新，需手动强制刷新。）用法: 在for循环后添加 。或者点击事件的时候， 需要改变某些状态值this.$forceUpdate(); //强制刷新，解决页面不会重新渲染的问题 vuex中，表单利用state的值的时候。 可以利用计算属性的set(value).去进行计算属性的双向绑定。更简单12345678910111213141516171819html:&lt;input v-model=&quot;message&quot;&gt;JS:computed: &#123; message: &#123; get () &#123; return this.$store.state.obj.message &#125;, set (value) &#123; this.$store.commit(&apos;updateMessage&apos;, value) &#125; &#125;&#125;store.js里面的mutations: &#123; updateMessage (state, message) &#123; state.obj.message = message &#125;&#125; 在严格模式下的使用vuex。 不能直接在v-model用vuex中的state中的值。因为能修改state的值。 唯一路径 还是mutations Vue 出现的一些错误 Uncaught TypeError: fn.bind is not a function检查一下methods里面嵌套的东西。 看会不会结构有问题 iconfont的基本用法1.把需要的icon添加到购物车2.如果需要哪个的话，添加到自己的项目之中。3.然后点击我的项目。 可以看到自己需要的图标。 和对应的图标代码。4.然后可以在该页面点击下载至我的本地。 然后进行相关操作5.下载iconfont.在asserts文件夹中。然后放入文件iconfont.css 创建iconfont. 放入文件iconfont.eot，iconfont.svg，iconfont.ttf，iconfont.woff。6.对于每次下载之后。 在文件夹iconfont里面的4个文件。 需要重新替换。7.在iconfont.css 需要更新64位的url. 把下载回来的iconfont中的64位替换之前的64位代码。– url(‘data:application/x-font-woff;charset=utf-8;base64,**–(因为第一次上面的src的路径，我们已经把绝对路径写好了。如果我们直接用最新的iconfont.css的话，又要写多一次路径。 所以直接改一次64位的就好了。 其它的就不用理了)最后 在Main.js import ‘styles/iconfont.css’。 css3 渐变属性 background-image: linear-gradient(top, rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.8));一个div 从一个方向到另外一个方向的样式渐变。 用 linear-gradient。第一个属性为方向（会往反方向渐变）。 第二个是初始颜色值。 第三个是到最终方向的颜色值。 —- 这是基础方法。 其中过渡的话。 可以看网站教学background-image: linear-gradient(to bottom, rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.8));等于background-image: linear-gradient(top, rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.8));详解：http://www.php.cn/css-tutorial-362595.html参数解释：http://www.php.cn/css-tutorial-362594.html swiper学习在我做过的这个项目之中。 虽然说vux是vue官网推荐使用的组件库。 不过swiper的话。 我觉的官网的比较好用。 用keep-alive 包住的组件里面有better-scroll— PC可以滑动。手机端偶现不能滑动em….最近在做一个项目。 突然发现用手机测试我做的项目的时候，被keep-alive包住的Better-scroll 不能滑动。 在网上找了很多，却不能找到解决方法。 后面记起了自己原来用keep-alive包住了这个组件。… 网上的人说keep-alive会有缓存作用，也会记录组件的位置。 就算我们跳转的时候，路由设置初始化高度到顶部，也会让这个better-scroll不能滑动。后来发现看过一些文章。 用手机测试的时候，会有一些缓存机制。 会记录上个页面的信息。 .. 会导致better-scroll不能滑动（我也没多清楚）解决方法：就是在activated函数 重新启动better-scroll1234activated()&#123; this.scroll = new BScroll(this.$refs.wrapper); this.scroll.refresh();&#125; render由于本人最近很忙，所以博客关于VUE的知识要在以后的日子慢慢才会写出来 我会讲关于vue.extend()组件的方法，递归组件，关于vuex在项目中的架构搭建等等知识。希望学无止境。","categories":[],"tags":[]},{"title":"亮眼操作：关于vux的v-transfer-dom的指令","slug":"Vue操作：关于vux的v-transfer-dom的指令","date":"2018-12-06T02:19:41.000Z","updated":"2018-12-13T07:22:22.322Z","comments":true,"path":"2018/12/06/Vue操作：关于vux的v-transfer-dom的指令/","link":"","permalink":"https://bolianglll.github.io/2018/12/06/Vue操作：关于vux的v-transfer-dom的指令/","excerpt":"","text":"在我自己的移动端项目实战项目中， 我在封装组件的时候，偶尔会弹出很多框，列如还有一些遮罩搭配弹窗的东西。 往往，我们为了复用性更高。 我们会封装成组件。问题来了， 我们要怎么定位到body的宽度，而去无视父组件的宽度和高度呢？ 这个时候，vux的v-transfer-dom指令， 就会让我们更容易的去封装这些弹框组。让代码更加简单 在我们开发的过程中，我们用到了Vux,而且遇到 Alert Popup XDialog等组件，我们可以用v-transfer-dom实现移动到body下。 必须有一个 div 作为占位元素否则会出错 1使用 注册局部指令1234567import &#123; TransferDom &#125; from &apos;vux&apos;export default &#123; directives: &#123; TransferDom &#125;&#125; 上面注意是在Vue 中的directives中引用这个指令 模板使用123&lt;div v-transfer-dom&gt; &lt;popup v-model=&quot;show&quot;&gt;&lt;/popup&gt;&lt;div&gt; 如果有博友想了解更多的关于移动端的布局。 现阶段的移动端的布局。 CSS可以去学习一下flex布局。 很适合现阶段的移动端布局","categories":[],"tags":[]},{"title":"在公司项目和自己实战项目的GIT干货操作","slug":"在公司项目和自己实战项目的GIT干货操作","date":"2018-12-06T02:19:41.000Z","updated":"2018-12-10T08:42:17.272Z","comments":true,"path":"2018/12/06/在公司项目和自己实战项目的GIT干货操作/","link":"","permalink":"https://bolianglll.github.io/2018/12/06/在公司项目和自己实战项目的GIT干货操作/","excerpt":"","text":"本博主会在以后的日子里 慢慢的分享出我遇到的困难~ 请期待~由于示范连接码云的图片有点多。 本博主也太会弄。 所以有关连接码云的操作，可以上网查。 这个主要讲GIT操作 我在网上看了下，也有其它比较好的GIT操作。 例如https://blog.csdn.net/youzhouliu/article/details/78952453这个博主的，写的也比较详细。下面写的是本人的经验。 如果还有其它难题，可以看看这个博主的处理 git创建版本库—公司的项目是用gitlab仓库的。 本人的项目是用码云保存代码的。 下面的介绍用码云上的操作来介绍外部连接提供：https://blog.csdn.net/gusy5188/article/details/80360096 连接码云 补充一下。里面没有介绍.ssh-rsa在哪，不用GIT去查的话，可以直接在露肩路径 这个文件在C:\\Users\\Administrator.ssh 中的id_rsa.pub文件里面。 可以复制内容在码云的SSH公钥中。 就是连接成功了。 接下来就是配置其它基本信息 GIT 的基本操作1 创建数据库12Git init //在一个文件目录执行该指令，会把该目录快速设置成Git的代码仓库。Git clone //从远程服务器clone工程，也会创建一个代码仓库。 2 提交修改git status 查看当前仓库状态。会提示那些文件发生修改，哪些内容需要add&amp;commit。git add . 把本地修改的文件，加入到本地的缓存区 （这里代表的是全部修改文件）git add 文件名 添加单个文件git commit -m “这次添加文件的注释” 将add的文件添加注释并且提交到代码仓库git push origin master(分支) 在git Bash 中修改远程的仓库地址在我的开发项目中， 会每过几个迭代，就会更新远程的用户名。要我们用这个新的用户名去管理git Lab上的代码。所以有时候系统不自动更新git bash上的远程账号的话，会无法拉取和提交。所以要修改远程的用户名。还有对于一些项目会迁移， 作为git仓库的服务器IP地址变了。 本地代码挺多，重新检出太占时间，可以修改一个什么配置让我本地仓库和新的远程仓库下面是解决方法： 方法一通过命令直接修改远程地址1进入你们项目目录2git remote 查看所有远程仓库， git remote xxx 查看指定远程仓库地址3git remote set-url origin http://xxxxxx/xxxxx.git 然后当你git pull yourorigin branch 的时候 他就会让你重新输入你在gitlab(github)上的user.name和password。 方法二 通过命令先删除再添加远程仓库1.进入你们项目目录git remote 查看所有远程仓库， git remote xxxx 查看指定远程仓库地址git remote rm origingit remote add origin http://xxxxxx/xxxxx.git 方法三 通过第三方git客户端修改。以SourceTree为例，点击 仓库 -&gt; 仓库配置 -&gt; 远程仓库 即可管理此项目中配置的所有远程仓库， 而且这个界面最下方还可以点击编辑配置文件。可以实现远程仓库的更换。","categories":[],"tags":[]},{"title":"关于CSS3中的 box-sizing border-box;","slug":"CSS3中的'' box-sizing border-box;'微妙之处","date":"2018-12-05T04:00:00.000Z","updated":"2018-12-05T09:29:14.481Z","comments":true,"path":"2018/12/05/CSS3中的'' box-sizing border-box;'微妙之处/","link":"","permalink":"https://bolianglll.github.io/2018/12/05/CSS3中的'' box-sizing border-box;'微妙之处/","excerpt":"","text":"在最近我在做自己的项目的过程之中， 在CSS中。我遇到了 box-sizing border-box;我通过用这个 box-sizing border-box;，简化了不少代码。 所以想在这通过网上的一些文章，和自己的一些理解来介绍一下 content-box指定元素的宽度和高度（最小/最大属性）适用于box的宽度和高度。元素的填充和边框布局和绘制指定宽度和高度除外 border-box指定宽度和高度（最小/最大属性）确定元素边框box。也就是说，对元素指定宽度和高度包括padding和border的指定。内容的宽度和高度减去各自双方该边框和填充的宽度从指定的”宽度”和”高度”属性计算 inherit指定box-sizing属性的值，应该从父元素继承 对于boder-box的计算方法border-box width 和 height 属性包括内容，内边距和边框，但不包括外边距。这是当文档处于 Quirks模式 时Internet Explorer使用的盒模型。注意，填充和边框将在盒子内 , 例如, .box {width: 350px; border: 10px solid black;} 导致在浏览器中呈现的宽度为350px的盒子。内容框不能为负，并且被分配到0，使得不可能使用border-box使元素消失。这里的维度计算为： width = border + padding + 内容的 width， height = border + padding + 内容的 height。 总结一般写页面对ui设计好的来说，我们最好使用这个属性，这样对整体布局很有好处，不然，页面很容易出现问题。 便于朋友记忆。 加多一个overflow:hidden的用法在此文章 overflow:hidden的作用是1.隐藏溢出的东西 #wai{ width:200px; background:#000; height:200px; border:2px blue solid; } #nei { float:left; width:300px; height:300px; background:red;} 当我们没有给wai这个div设置高度的时候，nei这个div的高度，就会撑开wai这个div，而在另一个方面，我们要注意到的是，当我们给wai这个div加上一个高度值，那么无论nei这个div的高度是多少，wai这个高度都是我们设定的值。而当nei的高度超过wai的高度的时候，超出的部分就会被隐藏。这就是隐藏溢出的含义!2.清楚浮动当nei这个div加上浮动这个属性的时候，在显示器的侧面，它已经脱离了wai这个div，也就是说，此时的nei的宽高是多少， 对于已经脱离了的wai来说，都是不起作用的。当我们全面的理解了浮动这个词的含义的时候，我们就理解overflow:hidden这个属性中的解释，清除浮动是什么意思了。也就是说，当我们给wai这个div加上overflow:hidden这个属性的时候，其中的nei等等带浮动属性的div的在这个立体的浮动已经被清除了。","categories":[],"tags":[]},{"title":"Flex布局-一个前端工程师必不可缺的布局","slug":"Flex布局-一个前端工程师必不可缺的布局","date":"2018-12-05T02:19:41.000Z","updated":"2018-12-10T08:57:33.237Z","comments":true,"path":"2018/12/05/Flex布局-一个前端工程师必不可缺的布局/","link":"","permalink":"https://bolianglll.github.io/2018/12/05/Flex布局-一个前端工程师必不可缺的布局/","excerpt":"","text":"最近项目中， 由于前端页面布局是页面小组做的。 我的小组的人忘记如何去布局了。在此想介绍一下FLEX布局给你们认识。作为web端和移动端的前流布局 Flex布局 参考阮一峰的文章flex布局 语法：http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html 实战：http://www.ruanyifeng.com/blog/2015/07/flex-examples.html 里面该有的都会有。 在下面 我讲解一下比较常用，然后到概念 flex:1; 让所有弹性盒模型对象的子元素都有相同的长度，忽略它们内部的内容","categories":[],"tags":[]},{"title":"关于eventloop事件循环机制和aysnc和await的解决异步方法的详解","slug":"关于eventloop事件监听机制和aysnc和await的解决异步方法的详解","date":"2018-12-04T02:19:41.000Z","updated":"2018-12-05T03:36:06.566Z","comments":true,"path":"2018/12/04/关于eventloop事件监听机制和aysnc和await的解决异步方法的详解/","link":"","permalink":"https://bolianglll.github.io/2018/12/04/关于eventloop事件监听机制和aysnc和await的解决异步方法的详解/","excerpt":"","text":"此文章是我在朋友推荐给我看的文章，然后我自己想总结一下关于eventloop事件和aysnc和await的事件解决顺序（不讲解其中原理。讲顺序）。如果我讲解的有问题。 麻烦发我邮箱，嘻嘻嘻。 很高兴大家帮我指出错误。 此文章是参考下面两个博客文章的解释。 如果我讲解的不清楚，你们可以去该文章了解一下,我觉的他们解释的挺清楚和挺好的。https://www.cnblogs.com/hanzhecheng/p/9046144.html eventloophttps://juejin.im/post/5c0397186fb9a049b5068e54 async eventloop事件循环机制JavaScript的事件分两种，宏任务(macro-task)和微任务(micro-task) 宏任务：包括整体代码script，setTimeout，setInterval微任务：Promise.then(非new Promise)，process.nextTick(node中) 事件的执行顺序，是先执行宏任务，然后执行微任务，这个是基础，任务可以有同步任务和异步任务，同步的进入主线程，异步的进入Event Table并注册函数，异步事件完成后，会将回调函数放入Event Queue中(宏任务和微任务是不同的Event Queue)，同步任务执行完成后，会从Event Queue中读取事件放入主线程执行，回调函数中可能还会包含不同的任务，因此会循环执行上述操作。 JS是单线程语言也就是说，JS一次只能做一件事情。cpu处理指令速度非常快，远比磁盘I/O和网络I/O速度快，所以一些cpu直接执行的任务就成了优先执行主线任务（即同步任务synchronous），然后需要io返回数据的任务就成了等待被执行的任务（即异步任务asynchronous）同步任务：在主线程上排队执行的任务，前一个任务执行完毕，才能执行后一个任务；异步任务：不进入主线程、而进入”任务队列”（task queue）的任务，只有”任务队列”通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。 代码解析12345678910111213141516171819console.log('1');setTimeout(function() &#123; console.log('2'); process.nextTick(function() &#123; console.log('3'); &#125;) new Promise(function(resolve) &#123; console.log('4'); resolve(); &#125;).then(function() &#123; console.log('5') &#125;)&#125;)输出：12435 宏任务同步代码console.log(‘1’),不多说setTimeout，加入宏任务Event Queue，没有发现微任务，第一轮事件循环走完第二轮事件循环开始，先执行宏任务，从宏任务Event Queue中独取出setTimeout的回调函数同步代码console.log(‘2’),发现process.nextTick，加入微任务Event Queuenew Promise，同步执行console.log(‘4’),发现then，加入微任务Event Queue宏任务执行完毕，接下来执行微任务，先执行process.nextTick，然后执行Promise.then微任务执行完毕，第二轮事件循环走完，没有发现宏任务，事件循环结束 总结:1.事件循环，先执行宏任务，其中同步任务立即执行，异步任务，加载到对应的的Event Queue中(setTimeout等加入宏任务的Event Queue，Promise.then加入微任务的Event Queue)，2.所有同步宏任务执行完毕后，如果发现微任务的Event Queue中有未执行的任务，会先执行其中的任务，这样算是完成了一次事件循环。3.接下来查看宏任务的Event Queue中是否有未执行的任务，有的话，就开始第二轮事件循环，依此类推。记得上面的宏任务和微任务的分类。这个就是JS的eventloop的循环时间机制 ES6async和await的解决异步函数方法-事件顺序1.async介绍 async function 用于声明 一个 返回 AsyncFunction 对象的异步函数。异步函数是值通过事件循环异步执行的函数，它会通过一个隐式的 Promise 返回其结果。如果你的代码使用了异步函数，它的语法和结构更像是标准的同步函数也就是说每一个async都会返回来一个隐式的 Promise .如果还想了解更多关于async的内容，可以去上面分享的那个博主的网站去看。 我在下面想分析关于async的事件顺序机制。下面的解释不代表博主的说法错误。本人只是想通过eventloop的解释，去解释下面的顺序 async Promise setTimeout(定时器) 的结合使用情况求下面输出结果1234567891011121314151617181920async function async1()&#123; console.log('async1 start') await async2() console.log('async1 end')&#125;async function async2()&#123; console.log('async2')&#125;console.log('script start')setTimeout(function()&#123; console.log('setTimeout')&#125;,0) async1();new Promise(function(resolve)&#123; console.log('promise1') resolve();&#125;).then(function()&#123; console.log('promise2')&#125;)console.log('script end') 正确的答案是：script startasync1 startasync2promise1script endpromise2async1 endsetTimeou 非常重要的一句是：遇到 await 表达式时，会让 async 函数 暂停执行，等到 await 后面的语句（Promise）状态发生改变（resolved或者rejected）之后，再恢复 async 函数的执行（再之后 await 下面的语句），并返回解析值（Promise的值） 解释上面的顺序：1.执行同步任务-console.log(‘script start’) /12.遇到了宏任务，且为异步的setTimeout。 把次函数加入到宏任务的Event Queue3.执行async1（）里面的同步代码 console.log(‘async1 start’)/24.执行 async2()里面的同步代码 console.log(‘async2’) /3（但是async2函数是给async定义的一个函数。 他会返回来一个隐式的promise对象,而且也会跳出上面的async1函数）4.执行promise的同步代码 console.log(‘promise1’)/4。 遇到了promise().resolve(). 返回来了一个promise对象，。5.执行同步console.log(‘script end’)/5。第一轮事件走完第二轮时间开始6执行async2()中的promise()。要等待reslove()。 把他压进队列（）。7执行.then后面的函数 console.log(‘promise2’)/6.第三轮开始等待完async2的promise()之后。 执行 console.log(‘async1 end’) 可能大家还没多理解。 我一开始也是。 然后我测试多了几次后列如 1234567891011121314151617181920async function async1()&#123; console.log('async1 start') await async2() console.log('async1 end')&#125; function async2()&#123; console.log('async2')&#125;console.log('script start')setTimeout(function()&#123; console.log('setTimeout')&#125;,0) async1();new Promise(function(resolve)&#123; console.log('promise1') resolve();&#125;).then(function()&#123; console.log('promise2')&#125;)console.log('script end') 正确的答案是：script startasync1 startasync2promise1script endasync1 endpromise2setTimeou 解释上面的顺序：第一轮事件和上面的类似。 但是没有async2()没有给async封装。 不会返回来一个promose()对象。所以第二轮有问题第一轮事件走完第二轮时间开始6.执行 console.log(‘async1 end’)7执行.then后面的函数 console.log(‘promise2’)上面的顺序就会有变化了。 总结一下：除此之外。我在一些评论下看到： 宏任务的优先级，是高于微任务的啊，settimeout 是去了下一个event loop。而且我们可以把await后面的代码。都当promise.then（微任务），这样就非常的好理解了—其实看到这， 我就更清楚上面的顺序了。。 哈哈 ，–新手理解。 当压进队列后，会从一开始再运行一下。 其实上面我讲的可能有点混乱。 但是这可能是我自己一开始比较好理解的方法。然后一步一步看到别人的想法，才更容易理解。 如果讲的不够清楚。可以去上面的那些博客主里面看一看。欢迎大家给我意见。","categories":[],"tags":[]},{"title":"“实战项目用到的技术总结”","slug":"“实战项目技术总结”","date":"2018-12-04T02:19:41.000Z","updated":"2018-12-27T05:00:52.354Z","comments":true,"path":"2018/12/04/“实战项目技术总结”/","link":"","permalink":"https://bolianglll.github.io/2018/12/04/“实战项目技术总结”/","excerpt":"","text":"大概先总结一下后面会总结。请等待 模仿去哪儿APP前端框架：Vue框架样式模板：iconfont,vue-awesome-swiper(vue里面推荐使用的轮播图)CSS:stylus数据传输工具：axious路由跳转：vue-router数据传输：get post的区别重点：GET把参数包含在URL中，POST通过request body传递参数。get的话 就是能获取数据， 但是不能保存。 就是表单那些不能保存Post的话 可以获取数据也能保存。 另外：GET请求在URL中传送的参数是有长度限制的，而POST么有。GET请求只能进行url编码，而POST支持多种编码方式数据存储：localStorage代码管理:Git，码云 公司项目XX（不透露）1.上了生产之后， 如何做到版本控制。 —-JSAPI上控制","categories":[],"tags":[]},{"title":"前端学习资料","slug":"前端学习资料","date":"2018-12-03T09:00:16.296Z","updated":"2018-12-11T09:19:14.660Z","comments":true,"path":"2018/12/03/前端学习资料/","link":"","permalink":"https://bolianglll.github.io/2018/12/03/前端学习资料/","excerpt":"","text":"作为一个前端攻城狮必须掌握的技能ES6阮一峰的ES6 是我觉的比较容易让人易懂和比较完善的教程。 http://es6.ruanyifeng.com/#docs/destructuring 代码规范化文章教程JSOC的规范化，是每一个攻城狮代码规范的标准。 值得学习 https://www.css88.com/doc/jsdoc/ HTTP跨域介绍-掘金的一篇好文推荐https://juejin.im/post/5a2f92c65188253e2470f16d#heading-5 前端面试题总结这是一个网上的团队总结的所有面试题。 我觉得这个文章不仅对我们面试有作用， 而且对于我们基础知识的提升也起很多作用。 值得我们去看看 https://yuchengkai.cn/docs/zh/frontend/ 个人学习介绍本人是主攻Web端的Vue攻城狮，我会在以后的日子里。慢慢的把我在实际项目中遇到的知识难点和亮点分享给各位热爱前端的同学。 哈哈哈， 我只是一个新手上路的菜鸟，如果看到我分享的只是有问题的话，很乐意你们去联系我。邮箱 - - - boliangleung@163.com希望我以后的东西能帮到大家","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2018-11-27T02:04:45.726Z","updated":"2018-12-03T08:12:49.829Z","comments":true,"path":"2018/11/27/hello-world/","link":"","permalink":"https://bolianglll.github.io/2018/11/27/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"什么是闭包","slug":"什么是闭包","date":"2018-11-01T08:40:11.000Z","updated":"2018-12-27T07:11:35.400Z","comments":true,"path":"2018/11/01/什么是闭包/","link":"","permalink":"https://bolianglll.github.io/2018/11/01/什么是闭包/","excerpt":"各种专业文献的闭包定义都非常抽象，我的理解是: 闭包就是能够读取其他函数内部变量的函数。 由于在javascript中，只有函数内部的子函数才能读取局部变量，所以说，闭包可以简单理解成“定义在一个函数内部的函数“。 所以，在本质上，闭包是将函数内部和函数外部连接起来的桥梁。","text":"各种专业文献的闭包定义都非常抽象，我的理解是: 闭包就是能够读取其他函数内部变量的函数。 由于在javascript中，只有函数内部的子函数才能读取局部变量，所以说，闭包可以简单理解成“定义在一个函数内部的函数“。 所以，在本质上，闭包是将函数内部和函数外部连接起来的桥梁。 闭包（closure）是javascript的一大难点，也是它的特色。很多高级应用都要依靠闭包来实现。 变量作用域要理解闭包，首先要理解javascript的特殊的变量作用域。 变量的作用域无非就两种：全局变量和局部变量。 javascript语言的特别之处就在于：函数内部可以直接读取全局变量，但是在函数外部无法读取函数内部的局部变量。 注意点：在函数内部声明变量的时候，一定要使用var命令。如果不用的话，你实际上声明的是一个全局变量！ 如何从外部读取函数内部的局部变量？出于种种原因，我们有时候需要获取到函数内部的局部变量。但是，上面已经说过了，正常情况下，这是办不到的！只有通过变通的方法才能实现。 那就是在函数内部，再定义一个函数。123456789function f1()&#123; var n=999; function f2()&#123; alert(n); // 999 &#125; &#125; 在上面的代码中，函数f2就被包括在函数f1内部，这时f1内部的所有局部变量，对f2都是可见的。但是反过来就不行，f2内部的局部变量，对f1就是不可见的。 这就是Javascript语言特有的&quot;链式作用域&quot;结构（chain scope）， 子对象会一级一级地向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的，反之则不成立。 既然f2可以读取f1中的局部变量，那么只要把f2作为返回值，我们不就可以在f1外部读取它的内部变量了吗！ 闭包的概念上面代码中的f2函数，就是闭包。 函数 A 返回了一个函数 B，并且函数 B 中使用了函数 A 的变量，函数 B 就被称为闭包。 举个栗子：1234567function A() &#123; let a = 1 function B() &#123; console.log(a) &#125; return B&#125; 你是否会疑惑，为什么函数 A 已经弹出调用栈了，为什么函数 B 还能引用到函数 A 中的变量。因为函数 A 中的变量这时候是存储在堆上的。现在的 JS 引擎可以通过逃逸分析辨别出哪些变量需要存储在堆上，哪些需要存储在栈上。 各种专业文献的闭包定义都非常抽象，我的理解是: 闭包就是能够读取其他函数内部变量的函数。 由于在javascript中，只有函数内部的子函数才能读取局部变量，所以说，闭包可以简单理解成“定义在一个函数内部的函数“。 所以，在本质上，闭包是将函数内部和函数外部连接起来的桥梁。 闭包的用途闭包可以用在许多地方。它的最大用处有两个，一个是前面提到的可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中，不会在f1调用后被自动清除。 为什么会这样呢？原因就在于f1是f2的父函数，而f2被赋给了一个全局变量，这导致f2始终在内存中，而f2的存在依赖于f1，因此f1也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage collection）回收。 这段代码中另一个值得注意的地方，就是”nAdd=function(){n+=1}”这一行，首先在nAdd前面没有使用var关键字，因此nAdd是一个全局变量，而不是局部变量。其次，nAdd的值是一个匿名函数（anonymous function），而这个匿名函数本身也是一个闭包，所以nAdd相当于是一个setter，可以在函数外部对函数内部的局部变量进行操作。 使用闭包的注意点（1）由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。 （2）闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。 经典面试题，循环中使用闭包解决 var 定义函数的问题12345for ( var i=1; i&lt;=5; i++) &#123; setTimeout( function timer() &#123; console.log( i ); &#125;, i*1000 );&#125; 首先因为 setTimeout 是个异步函数，所有会先把循环全部执行完毕，这时候 i 就是 6 了，所以会输出一堆 6。 解决办法两种，第一种使用闭包1234567for (var i = 1; i &lt;= 5; i++) &#123;(function(j) &#123; setTimeout(function timer() &#123; console.log(j); &#125;, j * 1000); &#125;)(i);&#125; 第二种就是使用 setTimeout 的第三个参数12345for ( var i=1; i&lt;=5; i++) &#123; setTimeout( function timer(j) &#123; console.log( j ); &#125;, i*1000, i);&#125; 第三种就是使用 let 定义 i 了12345for ( let i=1; i&lt;=5; i++) &#123; setTimeout( function timer() &#123; console.log( i ); &#125;, i*1000 );&#125; 因为对于 let 来说，他会创建一个块级作用域，相当于123456789101112131415161718&#123; // 形成块级作用域let i = 0&#123; let ii = i setTimeout( function timer() &#123; console.log( i ); &#125;, i*1000 );&#125;i++&#123; let ii = i&#125;i++&#123; let ii = i&#125;...&#125;","categories":[{"name":"js","slug":"js","permalink":"https://bolianglll.github.io/categories/js/"}],"tags":[{"name":"闭包","slug":"闭包","permalink":"https://bolianglll.github.io/tags/闭包/"}]}]}