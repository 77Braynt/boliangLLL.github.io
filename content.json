{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"John Doe","url":"https://bolianglll.github.io"},"pages":[],"posts":[{"title":"JS回收垃圾机制了解","slug":"JS回收垃圾机制了解","date":"2018-12-19T04:50:01.044Z","updated":"2018-12-19T05:00:15.728Z","comments":true,"path":"2018/12/19/JS回收垃圾机制了解/","link":"","permalink":"https://bolianglll.github.io/2018/12/19/JS回收垃圾机制了解/","excerpt":"","text":"参考：https://blog.csdn.net/qq_21325977/article/details/79973761最近有同事问我了解关于JS的回收机制不，发现自己没多懂。 所以在网上看了一下介绍。 希望能帮到你们。 我觉的， 了解就好。 不用硬记，这个我们实际开发用的比较少 了解一下 js 的垃圾回收机制原理：垃圾收集器会定期（周期性）找出那些不在继续使用的变量，然后释放其内存。 （1）标记清除法在函数声明一个变量的时候，就将这个变量标记为“进入环境”。从逻辑上讲，永远都不能释放进入环境的变量作占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。而当变量离开环境时，则将其标记为“离开环境”。垃圾回收器在运行时候会给存储在内存中中的所有变量都加上标记。然后它会去掉环境中的变量以及被环境中的变量引用的变量的标记（闭包）。在此之后再被标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后，垃圾回收器完成内存清楚工作，销毁那些带标记的值并回收他们所占用的内存空间123456functiontest()&#123; var a = 10 ; //被标记 ，进入环境 var b = 20 ; //被标记 ，进入环境 &#125; test(); //执行完毕 之后 a、b又被标离开环境，被回收 （2）引用计数法引用计数的含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是1。如果同一个值又被赋给另一个变量，则该值的引用次数加1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数减1。当这个值的引用次数变成0时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。这样，当垃圾回收器下次再运行时，它就会释放那些引用次数为0的值所占用的内存。 **但是很重要的一点是当遇到循环引用的时候，函数的引用次数就不会为0，所以不会被垃圾回收器回收内存，会造成内存泄露。在IE中涉及COM对象，就会存在循环引用的问题** 123456functiontest()&#123; var a = &#123;&#125; ; //a的引用次数为0 var b = a ; //a的引用次数加1，为1 var c =a; //a的引用次数再加1，为2 var b =&#123;&#125;; //a的引用次数减1，为1 对于内存泄露什么情况会引起内存泄漏？虽然有垃圾回收机制但是我们编写代码操作不当还是会造成内存泄漏。 意外的全局变量引起的内存泄漏。 原因：全局变量，不会被回收。解决：使用严格模式避免。 闭包引起的内存泄漏 原因：闭包可以维持函数内局部变量，使其得不到释放。解决：将事件处理函数定义在外部，解除闭包,或者在定义事件处理函数的外部函数中，删除对dom的引用。 没有清理的DOM元素引用 原因：虽然别的地方删除了，但是对象中还存在对dom的引用解决：手动删除。 被遗忘的定时器或者回调 原因：定时器中有dom的引用，即使dom删除了，但是定时器还在，所以内存中还是有这个dom。解决：手动删除定时器和dom。 子元素存在引用引起的内存泄漏 原因：div中的ul li 得到这个div，会间接引用某个得到的li，那么此时因为div间接引用li，即使li被清空，也还是在内存中，并且只要li不被删除，他的父元素都不会被删除。解决：手动删除清空","categories":[],"tags":[]},{"title":"深入了解Vuex原理","slug":"深入了解Vuex原理","date":"2018-12-12T16:00:00.000Z","updated":"2018-12-14T02:00:03.648Z","comments":true,"path":"2018/12/13/深入了解Vuex原理/","link":"","permalink":"https://bolianglll.github.io/2018/12/13/深入了解Vuex原理/","excerpt":"","text":"最近有个同事问了我很多关于vuex的原理和知识。 突然发现，好像最近做公司的项目，（项目原因，要自己在vue中封一个方法。例如localStorage.或者sessiontStorage） 好久没用vuex了。 都是用公司大佬封装的存储数据的方法~~~~。但是对于我们这些刚刚出去工作的人，或者在一些Vue项目的公司工作的话。 理解vuex原理是必不可少的。 那么接下来 想着分享vuex的原理。顺便帮自己复习一下。 转载：https://vuex.vuejs.org/zh/guide/ —vuex官网。如果你们觉的看官网更容易理解。 可以看官网。 我是按照自己更容易理解的方法。根据VUEX做一次笔记。 欢迎给意见。 介绍VUEXVuex是Vue.js应用程序的状态管理模式+库.它充当应用程序中所有组件的集中存储，其规则确保state只能以可预测的方式进行变更。它还与Vue的官方devtools扩展集成，以提供零配置时间旅行调试和状态快照导出/导入等高级功能。 State状态，这是真理，推动我们的应用程序的来源;View视图，这是仅仅一个声明性映射状态 ;Actions动作是状态可能因视图中的用户输入而改变的方式。 为什么要用vuex呢？Vue 属于一个单向数据流的程序。 -简单性但是，当我们有多个共享共同状态的组件时。 这种简单性就会崩溃 多个视图可能取决于同一个状态。不同观点的Actions可能需要改变同一个state。 对于问题一，对于深层嵌套组件，传递Data可能很乏味，而且对于兄弟组件根本不起作用。对于问题二，我们经常发现自己采用解决方案，例如到达直接父/子实例引用或尝试通过事件变异和同步状态的多个副本。这两种模式都很脆弱，很快导致无法维护的代码。 所以这个时候，就需要引入到了VUEX,从组件中提供共享的state（状态）。而且在全局中去管理他们。 有了这个。 才可以让组件树变成一个更大的视图。任何组件都可以访问state状态或者触发动作Actions。无论他们在哪个树原理图.Devtools属于Vue官方扩展集成的工具 Vuex核心State Getters Mutations Actions Modules VUEX入门 123456789101112131415161718192021222324252627282930313233343536373839404142//安装vuexnpm install vuex --save//在自己的src创建一个store目录。创建文件 index.js .然后引入Vueximport Vue from &apos;vue&apos;import Vuex from &apos;vuex&apos;Vue.use(Vuex)export default new Vuex.Store(&#123; state:&#123; city:&apos;上海&apos; &#125;, actions:&#123; changePatch(ctx,city)&#123; ctx.changeCity(&apos;city&apos;) &#125; &#125;, mutations:&#123; changeCity(state,city)&#123; state.city = city; &#125; &#125;&#125;)//在main.js引用import store from &apos;./store&apos;new Vue(&#123; el: &apos;#app&apos;, store,&#125;)// 在组件里面引用---最直接的引用 &lt;div class=&quot;button&quot;&gt;&#123;&#123;this.$store.state.city&#125;&#125;&lt;/div&gt;//对于上图的引用 vuex里面主要是通过state actions mutations来操作流程的。//当组件想修改state的数据的话。 mutations是唯一的方式。 所以要通过dispatch去修改actions。 再通过actions去修改Mutations。mutations再去修改state的值。 从而改变各个组件依赖这个state的值vue&lt;div class=&quot;button&quot; @click=&quot;handleCityChange(item.name)&quot;&gt;&#123;item.name&#125;&#125;&lt;/div&gt;JS handleCityChange(cityName)&#123; this.$store.dispatch(&apos;changePatch&apos;,cityName) &#125; store.js 如上方 其实上方的图是对于VUEX最原始的用法。但是 我们我们组件里传递的数据。 如果不是异步的话。 我们是可以直接去改变mutations。去修改的state的值。 一样是可以的 VUEX应用的核心是store库Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。 你不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。","categories":[],"tags":[]},{"title":"localStorage、sessionStorage、Cookie的区别及用法","slug":"localStorage、sessionStorage、Cookie的区别及用法","date":"2018-12-12T16:00:00.000Z","updated":"2018-12-13T04:43:51.845Z","comments":true,"path":"2018/12/13/localStorage、sessionStorage、Cookie的区别及用法/","link":"","permalink":"https://bolianglll.github.io/2018/12/13/localStorage、sessionStorage、Cookie的区别及用法/","excerpt":"","text":"由于在公司做vue项目。 不用vuex去存储数据。 都是基于localStorage、sessionStorage去封装的方法。 所以在网上去了解了一下他们的用法。和优势处。提升下自己项目经验 转载：https://segmentfault.com/a/1190000012057010 共同点：localStorage、sessionStorage、Cookie共同点：都是保存在浏览器端，且同源的 webstoragewebstorage是本地存储，存储在客户端，包括localStorage和sessionStorage。 localStoragelocalStorage生命周期是永久，这意味着除非用户显示在浏览器提供的UI上清除localStorage信息，否则这些信息将永远存在。存放数据大小为一般为5MB,而且它仅在客户端（即浏览器）中保存，不参与和服务器的通信。 localStorage的优势1、localStorage拓展了cookie的4K限制 2、localStorage会可以将第一次请求的数据直接存储到本地，这个相当于一个5M大小的针对于前端页面的数据库，相比于cookie可以节约带宽，但是这个却是只有在高版本的浏览器中才支持的 sessionStoragesessionStorage仅在当前会话下有效，关闭页面或浏览器后被清除。存放数据大小为一般为5MB,而且它仅在客户端（即浏览器）中保存，不参与和服务器的通信。源生接口可以接受，亦可再次封装来对Object和Array有更好的支持。 localStorage和sessionStorage使用时使用相同的API：1234567localStorage.setItem(&quot;key&quot;,&quot;value&quot;);//以“key”为名称存储一个值“value”localStorage.getItem(&quot;key&quot;);//获取名称为“key”的值localStorage.removeItem(&quot;key&quot;);//删除名称为“key”的信息。localStorage.clear();​//清空localStorage中所有信息 简单的举个例子来了解一下他们的用法仿一下京东官网顶部的广告关闭，效果为第一次进入官网会出现广告，然后点击关闭，刷新网页不会再显示广告，但是当清除localStorage存入的数据，刷新网页会再显示广告1234567891011121314151617181920212223&lt;div class=&quot;header&quot;&gt; &lt;div class=&quot;header-a&quot;&gt; &lt;a href=&quot;&quot;&gt;&lt;/a&gt; &lt;i class=&quot;close&quot;&gt;x&lt;/i&gt; &lt;/div&gt;&lt;/div&gt; &lt;script src=&quot;../js/jquery.min.js&quot;&gt;&lt;/script&gt;function haxi()&#123; //判断localStorage里有没有isClose if(localStorage.getItem(&quot;isClose&quot;))&#123; $(&quot;.header&quot;).hide(); &#125;else&#123; $(&quot;.header&quot;).show(); &#125; //点击关闭隐藏图片存取数据 $(&quot;.close&quot;).click(function()&#123; $(&quot;.header&quot;).fadeOut(1000); localStorage.setItem(&quot;isClose&quot;, &quot;1&quot;); &#125;) &#125; haxi(); 在项目里。 经常把一些弹框的判断。 存进这里面。 好让客户在选择之后。不再提示。或者从一个页面做出了一个操作之后。 把该页面的数据存进storage。 然后在其它页面。 读取该数据。 起到了一个相当于vuex的存储的效果 作用域不同不同浏览器无法共享localStorage或sessionStorage中的信息。相同浏览器的不同页面间可以共享相同的 localStorage（页面属于相同域名和端口），但是不同页面或标签页间无法共享sessionStorage的信息。这里需要注意的是，页面及标 签页仅指顶级窗口，如果一个标签页包含多个iframe标签且他们属于同源页面，那么他们之间是可以共享sessionStorage的 cookie生命期为只在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭。 存放数据大小为4K左右 。有个数限制（各浏览器不同），一般不能超过20个。与服务器端通信：每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题。但Cookie需要程序员自己封装，源生的Cookie接口不友好(http://www.jb51.net/article/6...)。用法和LoadStorage一样12345678910111213141516//Cookie方法&lt;script src=&quot;../js/cookie.js&quot;&gt;&lt;/script&gt;//Cookie函数自己封装引入function haxi()&#123; if(getCookie(&quot;isClose&quot;))&#123; $(&quot;.header&quot;).hide(); &#125;else&#123; $(&quot;.header&quot;).show(); &#125; $(&quot;.close&quot;).click(function()&#123; $(&quot;.header&quot;).fadeOut(1000); setCookie(&quot;isClose&quot;, &quot;1&quot;,&quot;s10&quot;); &#125;) &#125; haxi(); cookie的优点：具有极高的扩展性和可用性 1.通过良好的编程，控制保存在cookie中的session对象的大小。2.通过加密和安全传输技术，减少cookie被破解的可能性。3.只有在cookie中存放不敏感的数据，即使被盗取也不会有很大的损失。4.控制cookie的生命期，使之不会永远有效。这样的话偷盗者很可能拿到的就 是一个过期的cookie。 cookie的缺点 1.cookie的长度和数量的限制。每个domain最多只能有20条cookie，每个cookie长度不能超过4KB。否则会被截掉。2.安全性问题。如果cookie被人拦掉了，那个人就可以获取到所有session信息。加密的话也不起什么作用。3.有些状态不可能保存在客户端。例如，为了防止重复提交表单，我们需要在服务端保存一个计数器。若吧计数器保存在客户端，则起不到什么作用。","categories":[],"tags":[]},{"title":"对于制作滚动代码。JS中offsetTop、clientTop、scrollTop各位置属性详解","slug":"JS中offsetTop、clientTop、scrollTop、offsetTop各位置属性详解","date":"2018-12-12T07:31:21.947Z","updated":"2018-12-13T02:51:11.157Z","comments":true,"path":"2018/12/12/JS中offsetTop、clientTop、scrollTop、offsetTop各位置属性详解/","link":"","permalink":"https://bolianglll.github.io/2018/12/12/JS中offsetTop、clientTop、scrollTop、offsetTop各位置属性详解/","excerpt":"","text":"最近在做自己的一个web端项目（XXX）。 然后在制作滚动代码的时候， 发现自己对offsetTop、clientTop、scrollTop、offsetTop忘记的有点多。。。以前可能对这个操作行云流水的。。。哈哈哈，可能是做的公司Vue项目多， 很少用DOM操作。 突然来做一个滚动代码。。。。。所以，还是得温故而知新 转载：https://github.com/pramper/Blog/issues/10 说明offsetTop, offsetLeft：只读属性。要确定的这两个属性的值，首先得确定元素的offsetParent。offsetParent指的是距该元素最近的position不为static的祖先元素，如果没有则指向body元素。确定了offsetParent，offsetLeft指的是元素左侧偏移offsetParent的距离，同理offsetTop指的是上侧偏移的距离。offsetHeight, offsetWidth：只读属性。这两个属性返回的是元素的高度或宽度，包括元素的边框、内边距和滚动条。返回值是一个经过四舍五入的整数。（常用来计算为div的总宽度和总高度） scrollHeight, scrollWidth：只读属性。返回元素内容的整体尺寸，包括元素看不见的部分（需要滚动才能看见的）。返回值包括padding，但不包括margin和border。如下图： scrollHeight：IE、Opera 认为 scrollHeight 是网页内容实际高度，可以小于 clientHeight。FF 认为 scrollHeight 是网页内容高度，不过最小值是 clientHeight。scrollTop, scrollLeft：图中已经表示的很明白了。如果元素不能被滚动，则为0。clientTop：元素上边框的厚度，当没有指定边框厚底时，一般为0window.innerWidth, window.innerHeight：只读。视口（viewport）的尺寸，包含滚动条offsetHeight：获取对象相对于由offsetParent属性指定的父坐标(css定位的元素或body元素)的高度。IE、Opera 认为 offsetHeight = clientHeight + 滚动条 + 边框。FF 认为 offsetHeight 是网页内容实际高度，可以小于 clientHeight。offsetHeight在新版本的FF和IE中是一样的，表示网页的高度，与滚动条无关，chrome中不包括滚动条。clientHeight, clientWidth：包括padding，但不包括border, margin和滚动条。如下图： ———————————————–分隔线———————————————clientX、clientY：相对于浏览器窗口可视区域的X，Y坐标（窗口坐标），可视区域不包括工具栏和滚动条。IE事件和标准事件都定义了这2个属性。-手指移动的touches.clientY-自动这个属性。 可以来做手指滚动 pageX、pageY：类似于event.clientX、event.clientY，但它们使用的是文档坐标而非窗口坐标。这2个属性不是标准属性，但得到了广泛支持。IE事件中没有这2个属性。 offsetX、offsetY：相对于事件源元素（target或srcElement）的X,Y坐标，只有IE事件有这2个属性，标准事件没有对应的属性。 screenX、screenY：相对于用户显示器屏幕左上角的X,Y坐标。标准事件和IE事件都定义了这2个属性 常用的是clientX clientY screenX、screenY","categories":[],"tags":[]},{"title":"Vue.js个人经验总结","slug":"Vue.js个人总结","date":"2018-12-11T08:13:05.771Z","updated":"2018-12-27T04:59:20.063Z","comments":true,"path":"2018/12/11/Vue.js个人总结/","link":"","permalink":"https://bolianglll.github.io/2018/12/11/Vue.js个人总结/","excerpt":"","text":"其实Vue里，在我们开发中，大多数的东西我们都可以在vue.js的官网里找到。但是也有些 在你封指令或者组件时候。有更便捷的方法，或者可以用高级用法来形容。 自定义指令 除了核心功能默认内置的指令 (v-model 和 v-show)，Vue 也允许注册自定义指令。注意，在 Vue2.0 中，代码复用和抽象的主要形式是组件。然而，有的情况下，你仍然需要对普通 DOM 元素进行底层操作，这时候就会用到自定义指令。举个聚焦输入框的例子当页面加载时，该元素将获得焦点 (注意：autofocus 在移动版 Safari 上不工作)。事实上，只要你在打开这个页面后还没点击过任何内容，这个输入框就应当还是处于聚焦状态。现在让我们用指令来实现这个功能12345678// 注册一个全局自定义指令 `v-focus`Vue.directive(&apos;focus&apos;, &#123; // 当被绑定的元素插入到 DOM 中时…… inserted: function (el) &#123; // 聚焦元素 el.focus() &#125;&#125;) 如果想注册局部指令，组件中也接受一个 directives 的选项：12345678directives: &#123; focus: &#123; // 指令的定义 inserted: function (el) &#123; el.focus() &#125; &#125;&#125; 使用 然后你可以在模板中任何元素上使用新的 v-focus 属性，如下：1&lt;input v-focus&gt; 例如 VUX里面也提供了 TransferDom 的自定义指令。 this.$forUpdate() this.$forceUpdate() 处理页面刷新问题（v-for循环值刷新等）问题描述：在使用Vue框架开发时，在函数中改变了页面中的某个值，在函数中查看是修改成功了，但在页面中没有及时刷新改变后的值解决：运用 this.$forceUpdate() 强制刷新（因为数据层次太多，render函数没有自动更新，需手动强制刷新。）用法: 在for循环后添加 。或者点击事件的时候， 需要改变某些状态值this.$forceUpdate(); //强制刷新，解决页面不会重新渲染的问题 vuex中，表单利用state的值的时候。 可以利用计算属性的set(value).去进行计算属性的双向绑定。更简单12345678910111213141516171819html:&lt;input v-model=&quot;message&quot;&gt;JS:computed: &#123; message: &#123; get () &#123; return this.$store.state.obj.message &#125;, set (value) &#123; this.$store.commit(&apos;updateMessage&apos;, value) &#125; &#125;&#125;store.js里面的mutations: &#123; updateMessage (state, message) &#123; state.obj.message = message &#125;&#125; 在严格模式下的使用vuex。 不能直接在v-model用vuex中的state中的值。因为能修改state的值。 唯一路径 还是mutations Vue 出现的一些错误 Uncaught TypeError: fn.bind is not a function检查一下methods里面嵌套的东西。 看会不会结构有问题 iconfont的基本用法1.把需要的icon添加到购物车2.如果需要哪个的话，添加到自己的项目之中。3.然后点击我的项目。 可以看到自己需要的图标。 和对应的图标代码。4.然后可以在该页面点击下载至我的本地。 然后进行相关操作5.下载iconfont.在asserts文件夹中。然后放入文件iconfont.css 创建iconfont. 放入文件iconfont.eot，iconfont.svg，iconfont.ttf，iconfont.woff。6.对于每次下载之后。 在文件夹iconfont里面的4个文件。 需要重新替换。7.在iconfont.css 需要更新64位的url. 把下载回来的iconfont中的64位替换之前的64位代码。– url(‘data:application/x-font-woff;charset=utf-8;base64,**–(因为第一次上面的src的路径，我们已经把绝对路径写好了。如果我们直接用最新的iconfont.css的话，又要写多一次路径。 所以直接改一次64位的就好了。 其它的就不用理了)最后 在Main.js import ‘styles/iconfont.css’。 css3 渐变属性 background-image: linear-gradient(top, rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.8));一个div 从一个方向到另外一个方向的样式渐变。 用 linear-gradient。第一个属性为方向（会往反方向渐变）。 第二个是初始颜色值。 第三个是到最终方向的颜色值。 —- 这是基础方法。 其中过渡的话。 可以看网站教学background-image: linear-gradient(to bottom, rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.8));等于background-image: linear-gradient(top, rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.8));详解：http://www.php.cn/css-tutorial-362595.html参数解释：http://www.php.cn/css-tutorial-362594.html swiper学习在我做过的这个项目之中。 虽然说vux是vue官网推荐使用的组件库。 不过swiper的话。 我觉的官网的比较好用。 用keep-alive 包住的组件里面有better-scroll— PC可以滑动。手机端偶现不能滑动em….最近在做一个项目。 突然发现用手机测试我做的项目的时候，被keep-alive包住的Better-scroll 不能滑动。 在网上找了很多，却不能找到解决方法。 后面记起了自己原来用keep-alive包住了这个组件。… 网上的人说keep-alive会有缓存作用，也会记录组件的位置。 就算我们跳转的时候，路由设置初始化高度到顶部，也会让这个better-scroll不能滑动。后来发现看过一些文章。 用手机测试的时候，会有一些缓存机制。 会记录上个页面的信息。 .. 会导致better-scroll不能滑动（我也没多清楚）解决方法：就是在activated函数 重新启动better-scroll1234activated()&#123; this.scroll = new BScroll(this.$refs.wrapper); this.scroll.refresh();&#125; render由于本人最近很忙，所以博客关于VUE的知识要在以后的日子慢慢才会写出来 我会讲关于vue.extend()组件的方法，递归组件，关于vuex在项目中的架构搭建等等知识。希望学无止境。","categories":[],"tags":[]},{"title":"亮眼操作：关于vux的v-transfer-dom的指令","slug":"Vue操作：关于vux的v-transfer-dom的指令","date":"2018-12-06T02:19:41.000Z","updated":"2018-12-13T07:22:22.322Z","comments":true,"path":"2018/12/06/Vue操作：关于vux的v-transfer-dom的指令/","link":"","permalink":"https://bolianglll.github.io/2018/12/06/Vue操作：关于vux的v-transfer-dom的指令/","excerpt":"","text":"在我自己的移动端项目实战项目中， 我在封装组件的时候，偶尔会弹出很多框，列如还有一些遮罩搭配弹窗的东西。 往往，我们为了复用性更高。 我们会封装成组件。问题来了， 我们要怎么定位到body的宽度，而去无视父组件的宽度和高度呢？ 这个时候，vux的v-transfer-dom指令， 就会让我们更容易的去封装这些弹框组。让代码更加简单 在我们开发的过程中，我们用到了Vux,而且遇到 Alert Popup XDialog等组件，我们可以用v-transfer-dom实现移动到body下。 必须有一个 div 作为占位元素否则会出错 1使用 注册局部指令1234567import &#123; TransferDom &#125; from &apos;vux&apos;export default &#123; directives: &#123; TransferDom &#125;&#125; 上面注意是在Vue 中的directives中引用这个指令 模板使用123&lt;div v-transfer-dom&gt; &lt;popup v-model=&quot;show&quot;&gt;&lt;/popup&gt;&lt;div&gt; 如果有博友想了解更多的关于移动端的布局。 现阶段的移动端的布局。 CSS可以去学习一下flex布局。 很适合现阶段的移动端布局","categories":[],"tags":[]},{"title":"在公司项目和自己实战项目的GIT干货操作","slug":"在公司项目和自己实战项目的GIT干货操作","date":"2018-12-06T02:19:41.000Z","updated":"2018-12-10T08:42:17.272Z","comments":true,"path":"2018/12/06/在公司项目和自己实战项目的GIT干货操作/","link":"","permalink":"https://bolianglll.github.io/2018/12/06/在公司项目和自己实战项目的GIT干货操作/","excerpt":"","text":"本博主会在以后的日子里 慢慢的分享出我遇到的困难~ 请期待~由于示范连接码云的图片有点多。 本博主也太会弄。 所以有关连接码云的操作，可以上网查。 这个主要讲GIT操作 我在网上看了下，也有其它比较好的GIT操作。 例如https://blog.csdn.net/youzhouliu/article/details/78952453这个博主的，写的也比较详细。下面写的是本人的经验。 如果还有其它难题，可以看看这个博主的处理 git创建版本库—公司的项目是用gitlab仓库的。 本人的项目是用码云保存代码的。 下面的介绍用码云上的操作来介绍外部连接提供：https://blog.csdn.net/gusy5188/article/details/80360096 连接码云 补充一下。里面没有介绍.ssh-rsa在哪，不用GIT去查的话，可以直接在露肩路径 这个文件在C:\\Users\\Administrator.ssh 中的id_rsa.pub文件里面。 可以复制内容在码云的SSH公钥中。 就是连接成功了。 接下来就是配置其它基本信息 GIT 的基本操作1 创建数据库12Git init //在一个文件目录执行该指令，会把该目录快速设置成Git的代码仓库。Git clone //从远程服务器clone工程，也会创建一个代码仓库。 2 提交修改git status 查看当前仓库状态。会提示那些文件发生修改，哪些内容需要add&amp;commit。git add . 把本地修改的文件，加入到本地的缓存区 （这里代表的是全部修改文件）git add 文件名 添加单个文件git commit -m “这次添加文件的注释” 将add的文件添加注释并且提交到代码仓库git push origin master(分支) 在git Bash 中修改远程的仓库地址在我的开发项目中， 会每过几个迭代，就会更新远程的用户名。要我们用这个新的用户名去管理git Lab上的代码。所以有时候系统不自动更新git bash上的远程账号的话，会无法拉取和提交。所以要修改远程的用户名。还有对于一些项目会迁移， 作为git仓库的服务器IP地址变了。 本地代码挺多，重新检出太占时间，可以修改一个什么配置让我本地仓库和新的远程仓库下面是解决方法： 方法一通过命令直接修改远程地址1进入你们项目目录2git remote 查看所有远程仓库， git remote xxx 查看指定远程仓库地址3git remote set-url origin http://xxxxxx/xxxxx.git 然后当你git pull yourorigin branch 的时候 他就会让你重新输入你在gitlab(github)上的user.name和password。 方法二 通过命令先删除再添加远程仓库1.进入你们项目目录git remote 查看所有远程仓库， git remote xxxx 查看指定远程仓库地址git remote rm origingit remote add origin http://xxxxxx/xxxxx.git 方法三 通过第三方git客户端修改。以SourceTree为例，点击 仓库 -&gt; 仓库配置 -&gt; 远程仓库 即可管理此项目中配置的所有远程仓库， 而且这个界面最下方还可以点击编辑配置文件。可以实现远程仓库的更换。","categories":[],"tags":[]},{"title":"关于CSS3中的 box-sizing border-box;","slug":"CSS3中的'' box-sizing border-box;'微妙之处","date":"2018-12-05T04:00:00.000Z","updated":"2018-12-05T09:29:14.481Z","comments":true,"path":"2018/12/05/CSS3中的'' box-sizing border-box;'微妙之处/","link":"","permalink":"https://bolianglll.github.io/2018/12/05/CSS3中的'' box-sizing border-box;'微妙之处/","excerpt":"","text":"在最近我在做自己的项目的过程之中， 在CSS中。我遇到了 box-sizing border-box;我通过用这个 box-sizing border-box;，简化了不少代码。 所以想在这通过网上的一些文章，和自己的一些理解来介绍一下 content-box指定元素的宽度和高度（最小/最大属性）适用于box的宽度和高度。元素的填充和边框布局和绘制指定宽度和高度除外 border-box指定宽度和高度（最小/最大属性）确定元素边框box。也就是说，对元素指定宽度和高度包括padding和border的指定。内容的宽度和高度减去各自双方该边框和填充的宽度从指定的”宽度”和”高度”属性计算 inherit指定box-sizing属性的值，应该从父元素继承 对于boder-box的计算方法border-box width 和 height 属性包括内容，内边距和边框，但不包括外边距。这是当文档处于 Quirks模式 时Internet Explorer使用的盒模型。注意，填充和边框将在盒子内 , 例如, .box {width: 350px; border: 10px solid black;} 导致在浏览器中呈现的宽度为350px的盒子。内容框不能为负，并且被分配到0，使得不可能使用border-box使元素消失。这里的维度计算为： width = border + padding + 内容的 width， height = border + padding + 内容的 height。 总结一般写页面对ui设计好的来说，我们最好使用这个属性，这样对整体布局很有好处，不然，页面很容易出现问题。 便于朋友记忆。 加多一个overflow:hidden的用法在此文章 overflow:hidden的作用是1.隐藏溢出的东西 #wai{ width:200px; background:#000; height:200px; border:2px blue solid; } #nei { float:left; width:300px; height:300px; background:red;} 当我们没有给wai这个div设置高度的时候，nei这个div的高度，就会撑开wai这个div，而在另一个方面，我们要注意到的是，当我们给wai这个div加上一个高度值，那么无论nei这个div的高度是多少，wai这个高度都是我们设定的值。而当nei的高度超过wai的高度的时候，超出的部分就会被隐藏。这就是隐藏溢出的含义!2.清楚浮动当nei这个div加上浮动这个属性的时候，在显示器的侧面，它已经脱离了wai这个div，也就是说，此时的nei的宽高是多少， 对于已经脱离了的wai来说，都是不起作用的。当我们全面的理解了浮动这个词的含义的时候，我们就理解overflow:hidden这个属性中的解释，清除浮动是什么意思了。也就是说，当我们给wai这个div加上overflow:hidden这个属性的时候，其中的nei等等带浮动属性的div的在这个立体的浮动已经被清除了。","categories":[],"tags":[]},{"title":"Flex布局-一个前端工程师必不可缺的布局","slug":"Flex布局-一个前端工程师必不可缺的布局","date":"2018-12-05T02:19:41.000Z","updated":"2018-12-10T08:57:33.237Z","comments":true,"path":"2018/12/05/Flex布局-一个前端工程师必不可缺的布局/","link":"","permalink":"https://bolianglll.github.io/2018/12/05/Flex布局-一个前端工程师必不可缺的布局/","excerpt":"","text":"最近项目中， 由于前端页面布局是页面小组做的。 我的小组的人忘记如何去布局了。在此想介绍一下FLEX布局给你们认识。作为web端和移动端的前流布局 Flex布局 参考阮一峰的文章flex布局 语法：http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html 实战：http://www.ruanyifeng.com/blog/2015/07/flex-examples.html 里面该有的都会有。 在下面 我讲解一下比较常用，然后到概念 flex:1; 让所有弹性盒模型对象的子元素都有相同的长度，忽略它们内部的内容","categories":[],"tags":[]},{"title":"关于eventloop事件循环机制和aysnc和await的解决异步方法的详解","slug":"关于eventloop事件监听机制和aysnc和await的解决异步方法的详解","date":"2018-12-04T02:19:41.000Z","updated":"2018-12-05T03:36:06.566Z","comments":true,"path":"2018/12/04/关于eventloop事件监听机制和aysnc和await的解决异步方法的详解/","link":"","permalink":"https://bolianglll.github.io/2018/12/04/关于eventloop事件监听机制和aysnc和await的解决异步方法的详解/","excerpt":"","text":"此文章是我在朋友推荐给我看的文章，然后我自己想总结一下关于eventloop事件和aysnc和await的事件解决顺序（不讲解其中原理。讲顺序）。如果我讲解的有问题。 麻烦发我邮箱，嘻嘻嘻。 很高兴大家帮我指出错误。 此文章是参考下面两个博客文章的解释。 如果我讲解的不清楚，你们可以去该文章了解一下,我觉的他们解释的挺清楚和挺好的。https://www.cnblogs.com/hanzhecheng/p/9046144.html eventloophttps://juejin.im/post/5c0397186fb9a049b5068e54 async eventloop事件循环机制JavaScript的事件分两种，宏任务(macro-task)和微任务(micro-task) 宏任务：包括整体代码script，setTimeout，setInterval微任务：Promise.then(非new Promise)，process.nextTick(node中) 事件的执行顺序，是先执行宏任务，然后执行微任务，这个是基础，任务可以有同步任务和异步任务，同步的进入主线程，异步的进入Event Table并注册函数，异步事件完成后，会将回调函数放入Event Queue中(宏任务和微任务是不同的Event Queue)，同步任务执行完成后，会从Event Queue中读取事件放入主线程执行，回调函数中可能还会包含不同的任务，因此会循环执行上述操作。 JS是单线程语言也就是说，JS一次只能做一件事情。cpu处理指令速度非常快，远比磁盘I/O和网络I/O速度快，所以一些cpu直接执行的任务就成了优先执行主线任务（即同步任务synchronous），然后需要io返回数据的任务就成了等待被执行的任务（即异步任务asynchronous）同步任务：在主线程上排队执行的任务，前一个任务执行完毕，才能执行后一个任务；异步任务：不进入主线程、而进入”任务队列”（task queue）的任务，只有”任务队列”通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。 代码解析12345678910111213141516171819console.log('1');setTimeout(function() &#123; console.log('2'); process.nextTick(function() &#123; console.log('3'); &#125;) new Promise(function(resolve) &#123; console.log('4'); resolve(); &#125;).then(function() &#123; console.log('5') &#125;)&#125;)输出：12435 宏任务同步代码console.log(‘1’),不多说setTimeout，加入宏任务Event Queue，没有发现微任务，第一轮事件循环走完第二轮事件循环开始，先执行宏任务，从宏任务Event Queue中独取出setTimeout的回调函数同步代码console.log(‘2’),发现process.nextTick，加入微任务Event Queuenew Promise，同步执行console.log(‘4’),发现then，加入微任务Event Queue宏任务执行完毕，接下来执行微任务，先执行process.nextTick，然后执行Promise.then微任务执行完毕，第二轮事件循环走完，没有发现宏任务，事件循环结束 总结:1.事件循环，先执行宏任务，其中同步任务立即执行，异步任务，加载到对应的的Event Queue中(setTimeout等加入宏任务的Event Queue，Promise.then加入微任务的Event Queue)，2.所有同步宏任务执行完毕后，如果发现微任务的Event Queue中有未执行的任务，会先执行其中的任务，这样算是完成了一次事件循环。3.接下来查看宏任务的Event Queue中是否有未执行的任务，有的话，就开始第二轮事件循环，依此类推。记得上面的宏任务和微任务的分类。这个就是JS的eventloop的循环时间机制 ES6async和await的解决异步函数方法-事件顺序1.async介绍 async function 用于声明 一个 返回 AsyncFunction 对象的异步函数。异步函数是值通过事件循环异步执行的函数，它会通过一个隐式的 Promise 返回其结果。如果你的代码使用了异步函数，它的语法和结构更像是标准的同步函数也就是说每一个async都会返回来一个隐式的 Promise .如果还想了解更多关于async的内容，可以去上面分享的那个博主的网站去看。 我在下面想分析关于async的事件顺序机制。下面的解释不代表博主的说法错误。本人只是想通过eventloop的解释，去解释下面的顺序 async Promise setTimeout(定时器) 的结合使用情况求下面输出结果1234567891011121314151617181920async function async1()&#123; console.log('async1 start') await async2() console.log('async1 end')&#125;async function async2()&#123; console.log('async2')&#125;console.log('script start')setTimeout(function()&#123; console.log('setTimeout')&#125;,0) async1();new Promise(function(resolve)&#123; console.log('promise1') resolve();&#125;).then(function()&#123; console.log('promise2')&#125;)console.log('script end') 正确的答案是：script startasync1 startasync2promise1script endpromise2async1 endsetTimeou 非常重要的一句是：遇到 await 表达式时，会让 async 函数 暂停执行，等到 await 后面的语句（Promise）状态发生改变（resolved或者rejected）之后，再恢复 async 函数的执行（再之后 await 下面的语句），并返回解析值（Promise的值） 解释上面的顺序：1.执行同步任务-console.log(‘script start’) /12.遇到了宏任务，且为异步的setTimeout。 把次函数加入到宏任务的Event Queue3.执行async1（）里面的同步代码 console.log(‘async1 start’)/24.执行 async2()里面的同步代码 console.log(‘async2’) /3（但是async2函数是给async定义的一个函数。 他会返回来一个隐式的promise对象,而且也会跳出上面的async1函数）4.执行promise的同步代码 console.log(‘promise1’)/4。 遇到了promise().resolve(). 返回来了一个promise对象，。5.执行同步console.log(‘script end’)/5。第一轮事件走完第二轮时间开始6执行async2()中的promise()。要等待reslove()。 把他压进队列（）。7执行.then后面的函数 console.log(‘promise2’)/6.第三轮开始等待完async2的promise()之后。 执行 console.log(‘async1 end’) 可能大家还没多理解。 我一开始也是。 然后我测试多了几次后列如 1234567891011121314151617181920async function async1()&#123; console.log('async1 start') await async2() console.log('async1 end')&#125; function async2()&#123; console.log('async2')&#125;console.log('script start')setTimeout(function()&#123; console.log('setTimeout')&#125;,0) async1();new Promise(function(resolve)&#123; console.log('promise1') resolve();&#125;).then(function()&#123; console.log('promise2')&#125;)console.log('script end') 正确的答案是：script startasync1 startasync2promise1script endasync1 endpromise2setTimeou 解释上面的顺序：第一轮事件和上面的类似。 但是没有async2()没有给async封装。 不会返回来一个promose()对象。所以第二轮有问题第一轮事件走完第二轮时间开始6.执行 console.log(‘async1 end’)7执行.then后面的函数 console.log(‘promise2’)上面的顺序就会有变化了。 总结一下：除此之外。我在一些评论下看到： 宏任务的优先级，是高于微任务的啊，settimeout 是去了下一个event loop。而且我们可以把await后面的代码。都当promise.then（微任务），这样就非常的好理解了—其实看到这， 我就更清楚上面的顺序了。。 哈哈 ，–新手理解。 当压进队列后，会从一开始再运行一下。 其实上面我讲的可能有点混乱。 但是这可能是我自己一开始比较好理解的方法。然后一步一步看到别人的想法，才更容易理解。 如果讲的不够清楚。可以去上面的那些博客主里面看一看。欢迎大家给我意见。","categories":[],"tags":[]},{"title":"“实战项目用到的技术总结”","slug":"“实战项目技术总结”","date":"2018-12-04T02:19:41.000Z","updated":"2018-12-27T05:00:52.354Z","comments":true,"path":"2018/12/04/“实战项目技术总结”/","link":"","permalink":"https://bolianglll.github.io/2018/12/04/“实战项目技术总结”/","excerpt":"","text":"大概先总结一下后面会总结。请等待 模仿去哪儿APP前端框架：Vue框架样式模板：iconfont,vue-awesome-swiper(vue里面推荐使用的轮播图)CSS:stylus数据传输工具：axious路由跳转：vue-router数据传输：get post的区别重点：GET把参数包含在URL中，POST通过request body传递参数。get的话 就是能获取数据， 但是不能保存。 就是表单那些不能保存Post的话 可以获取数据也能保存。 另外：GET请求在URL中传送的参数是有长度限制的，而POST么有。GET请求只能进行url编码，而POST支持多种编码方式数据存储：localStorage代码管理:Git，码云 公司项目XX（不透露）1.上了生产之后， 如何做到版本控制。 —-JSAPI上控制","categories":[],"tags":[]},{"title":"成长的点点滴滴基础","slug":"成长的点点滴滴基础","date":"2018-12-04T02:19:41.000Z","updated":"2018-12-27T03:05:43.745Z","comments":true,"path":"2018/12/04/成长的点点滴滴基础/","link":"","permalink":"https://bolianglll.github.io/2018/12/04/成长的点点滴滴基础/","excerpt":"","text":"最近写多了vue的项目， 之前的JS和CSS和其它知识用的比较少了。 下面的知识是方便回忆的~~~~没啥事记下笔记 JS标准库：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/assign(这个博主里面还有很多学习资料提供) 2018 啊里的面试题。个人觉得，偶尔看看面试题，不是为了去面试，而是看下面试题，去了解一下深层的概念和知识.https://blog.csdn.net/Carrie_zzz/article/details/80201131 get和Post区别数据传输：get post的区别重点：GET把参数包含在URL中（数据比较少），POST通过request body传递参数。get的话 就是能获取数据， 但是不能保存。 就是表单那些不能保存Post的话 可以获取数据也能保存。 另外：GET请求在URL中传送的参数是有长度限制的，而POST么有。GET请求只能进行url编码，而POST支持多种编码方式 判断一个变量类型是数组还是对象1.通过length属性：一般情况下对象没有length属性值，其值为undefiend，而数组的length值为number类型 缺点：非常不实用，当对象的属性存在length，且其值为number（比如类数组），则该方法失效，不建议使用，看看即可。2.通过instanceof来判断区分12345678var arr = [1, 2, 3]; var obj = &#123; name: &apos;lyl&apos;, age: 18, 1: &apos;name&apos; &#125; console.log(arr instanceof Array); //true console.log(obj instanceof Array); //false 3.通过constructor12345678var arr = [1, 2, 3]; var obj = &#123; name: &apos;lyl&apos;, age: 18, 1: &apos;name&apos; &#125; console.log(arr.constructor === Array); //true console.log(obj.constructor === Array); //false 通过toString()方法，数组原型和对象原型定义的toString()方法不同-可以判断任何类型12345678 var arr = [1, 2, 3];var obj = &#123; name: &apos;lyl&apos;, age: 18, 1: &apos;name&apos;&#125;console.log(Object.prototype.toString.call(arr) === &apos;[object Array]&apos;); //trueconsole.log(Object.prototype.toString.call(boj) === &apos;[object Array]&apos;); //false 5.随便找一个数组仅有的方法，来判断数组和对象谁有该方法即可（样例以sort来举例）123456789 var arr = [1, 2, 3];var obj = &#123; name: &apos;lyl&apos;, age: 18, 1: &apos;name&apos;&#125; console.log(arr.sort === Array.prototype.sort); //trueconsole.log(obj.sort === Array.prototype.sort); //false 总结：方法应用权重： 优先使用方四toString，因为该方法几乎无缺陷。 次之可以使用方二instanceof和方三constructor 剩下的方法玩玩即可，不实用 js === 和==的区别== 用于比较 判断 两者相等 ==在比较的时候可以转自动换数据类型===用于严格比较 判断两者严格相等 ===严格比较，不会进行自动转换==会进行隐式类型转换总之： “==” 只要求值相等; “===” 要求值和类型都相等 display中 block 和 inline 和 inline-block区别display:blockblock元素会独占一行，多个block元素会各自新起一行。默认情况下，block元素宽度自动填满其父元素宽度。block元素可以设置width,height属性。块级元素即使设置了宽度,仍然是独占一行。block元素可以设置margin和padding属性。 display:inlineinline元素不会独占一行，多个相邻的行内元素会排列在同一行里，直到一行排列不下，才会新换一行，其宽度随元素的内容而变化。inline元素设置width,height属性无效。inline元素的margin和padding属性，水平方向的padding-left, padding-right, margin-left, margin-right都产生边距效果；但竖直方向的padding-top, padding-bottom, margin-top, margin-bottom不会产生边距效果。 display:inline-block简单来说就是将对象呈现为inline对象，但是对象的内容作为block对象呈现。之后的内联对象会被排列在同一行内。比如我们可以给一个link（a元素）inline-block属性值，使其既具有block的宽度高度特性又具有inline的同行特性。 Object.assign()方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。–常用Object.assign(target, …sources) target 目标对象。sources 源对象。1234567891011121314const object1 = &#123; a: 1, b: 2, c: 3&#125;;const object2 = Object.assign(&#123;c: 4, d: 5&#125;, object1);console.log(object2.c, object2.d);下面的写法是错的。 因为...item运算符不能添加进Object.assign.会看做是空。所以穿item return this.mallData.mhPicsListStr.map(item =&gt; &#123; return Object.assign(&#123;&#125;, ...item, &#123; picsAdd: this.ip+item.picsAdd &#125;); &#125;);// expected output: 3 5 功能：1.合并对象 2.合并具有相同属性的对象…还有很多该方法属于浅拷贝，当sources源对象发生变化时。新的object中的值也会改变 Object.prototype.toString(). 检测数据的数据类型。最好用，最规范的123456789var toString = Object.prototype.toString;toString.call(new Date); // [object Date]toString.call(new String); // [object String]toString.call(Math); // [object Math]//Since JavaScript 1.8.5toString.call(undefined); // [object Undefined]toString.call(null); // [object Null] 123var isArray = function (obj) &#123; // 判断对象是否是数组的标准方法 return Object.prototype.toString.call(obj) === &quot;[object Array]&quot;;&#125;; 返回的值是[object 类型] Obj.hasOwnProperty() 方法会返回一个布尔值，指示对象自身属性中是否具有指定的属性prop 要检测的属性 字符串 名称或者 Symbol。本人常用的是用来检测 prop1234567891011o = new Object();o.prop = &apos;exists&apos;;function changeO() &#123; o.newprop = o.prop; delete o.prop;&#125;o.hasOwnProperty(&apos;prop&apos;); // 返回 truechangeO();o.hasOwnProperty(&apos;prop&apos;); // 返回 false 注意JavaScript 并没有保护 hasOwnProperty 属性名，因此某个对象是有可能存在使用这个属性名的属性，使用外部的 hasOwnProperty 获得正确的结果是需要的： 把数组降维简单的：123var res = arr.reduce((beginList,item)=&gt;&#123; return beginList.concat(item)&#125;,[]) 但是对于var arr = [1, 2, [3, 4, [5]]]。这样的话。需要用递归方法或者reduce()123456789101112131415161718递归var recursion=function(arr)&#123; var len=arr.length,newarr=[]; for(var i=0;i&lt;len;i++)&#123; if(Array.isArray(arr[i])) newarr.push.apply(newarr,recursion(arr[i])) else newarr.push(arr[i]) &#125; return newarr&#125;更好的方法：reducelet flatten = arr =&gt; arr.reduce((begin,current)=&gt;&#123; Array.isArray(current)? begin.push(...flatten(current)): begin.push(current); return begin &#125;,[]) 找出数组中出现的次数超过一半以上的选项123456789101112131415161718192021222324function getItem(arr = []) &#123; const half = Math.floor(arr.length / 2) let result = [] let m = new Map() arr.map(item =&gt; &#123; m.has(item) ? m.set(item, m.get(item) + 1) : m.set(item, 1) if (m.get(item) &gt;= half) &#123; !result.includes(item) &amp;&amp; result.push(item) &#125; &#125;) return result.length ? result : 0 &#125;本人list.reduce((beginList, item) =&gt; &#123;if (item in beginList) &#123;beginList[item] ++;&#125;else &#123;beginList[item] = 1;&#125;return beginList;&#125;, &#123;&#125;);先求出数组的所有内容出现的次数。 然后再循环一次看那个长度超出一半。 []==![] 结果返回来true==发生js隐式转换。对于JS隐式转换的解释方案。https://juejin.im/post/5bc5c752f265da0a9a399a62 数组去重最简单的就是ES6的语法 new Set();12345aca=[&apos;66&apos;,&apos;88&apos;,undefined,NaN,undefined,NaN]let bbg = new Set(aca)//Set(4) &#123;&quot;66&quot;, &quot;88&quot;, undefined, NaN&#125;Array.from(bbg)//(4) [&quot;66&quot;, &quot;88&quot;, undefined, NaN] 1234567891011121314151617181920212223-------------------------对象属性去重function unique(arr)&#123; var res =[]; var json = &#123;&#125;; for(var i=0;i&lt;arr.length;i++)&#123; if(!json[arr[i]])&#123; res.push(arr[i]); json[arr[i]] = 1; &#125; &#125; return res;&#125;-----------------------reduce---arr3 = aa =&gt;aa.reduce((begin,items)=&gt;&#123;if(begin.includes(items))&#123;begin.push(items)&#125;return begin&#125;,[])封装诚一个函数 上面indexOf 只能对于字符串有效果。 对于一些数组里面有underfined Object类型的。 indexOf 数组去重不了.所以要用ES6的数组新语法。 includes();123456bb=[undefined,&#123;&#125;,&#123;&#125;,Object,undefined]bb.forEach(item =&gt;&#123;if(!eray1.includes(item))&#123;eray1.push(item)&#125;&#125;) 但是对于{} 。 includes({})会返回来false.也无法处理。 {}==={}也是会返回来false。处理方式的话 Object.prototype.toString.call({})。做特殊处理。 一般来讲的话。 includes已经够用了 不用ES6的语法解决12345678910111213141516171819 function (arr1=[])&#123; var result = []; var flag = true; //控制NaN for(var i=0;i&lt;arr1.length;i++)&#123; if(result.indexOf(arr1[i])==-1)&#123; if(this[i]!=this.[i]) //因为IndexOf监控不了NaN值。 需要做一层处理 includes()可以。体验ES6的好处 &#123; if(flag)&#123; result.push(arr1[i]); flag = false &#125; &#125; else&#123; result.push(arr1[i]); &#125; &#125; &#125; return result;&#125; 12345678用过滤器去解决 性能更好&apos;use strict&apos;; var r,arr = [&apos;apple&apos;, &apos;strawberry&apos;, &apos;banana&apos;, &apos;pear&apos;, &apos;apple&apos;, &apos;orange&apos;, &apos;orange&apos;, &apos;strawberry&apos;]; r = arr.filter(function (element, index, self) &#123; return self.indexOf(element) === index; &#125;);console.log(r.toString()); 小牛第四年会变老，老牛一年生一条小牛。然后第一年买了一条小牛。求N年后多少条1234567891011121314151617181920/** *自己的答案 *@param &#123;Array&#125; origin -源车间 *@param &#123;Number&#125; n 年数*/function getOrigin(origin,n)&#123; const createCatle = cattle =&gt;&#123; cattle.age++; cattle.age &gt;=4&amp;&amp; origin.push(&#123;age:1&#125;) &#125; for(let i=0;i&lt;n;i++)&#123; origin.forEach(item=&gt;createCatle(item)) &#125;&#125;let origin = [&#123;age:1&#125;]getOrigin(origin,9)总数等于 origin.length网上答案： 斐波那契数列算法 封装一个函数，参数是定时器的时间，.then执行回调函数1234567891011function setTimeGo(times)&#123;return new Promise((resolve,reject)=&gt;&#123; setTimeout(()=&gt;&#123; resolve();&#125;,times)&#125;)&#125;setTimeGo(2000).then(res=&gt;&#123; console.log(&apos;lblblbl&apos;)&#125;)//setTimeout是没有回调then的功能。 需要借助new Promise。去实现.then的回调函数 .js 实现 ajax 请求或者submit请求时 锁屏功能以及开锁功能（请求时界面Loading以及元素不能点击，请求完成即消除Loading）1234567891011121314151617function(url, fn) &#123; var obj = new XMLHttpRequest(); // XMLHttpRequest对象用于在后台与服务器交换数据 obj.open(&apos;GET&apos;, url, true); obj.onreadystatechange= function() &#123; if(obj.readyState == 4 &amp;&amp; obj.status == 200||obj.status == 304) &#123; loading.style.display = &quot;none&quot; &#125; else &#123; alert(&quot;不能点击,哈哈哈!&quot;); &#125; &#125;;obj.send(null);&#125; 检验对象里面包不包含某个字段 res.hasOwnProperty(‘checkboxState’). indexOf检测数组还有字符串。不能检测字符串注意： indexOf是不能检测对象的。 所以不要看经常用就啥用。对于某些同学们 IndexOf 只能检测部分数组1234567891011121314gg=[&apos;a&apos;,&apos;b&apos;]console.log(gg.indexOf(&apos;a&apos;)&gt;&gt;&gt;&gt;&gt;&gt;0)pp=[&#123;a:22&#125;,&#123;b:33&#125;]console.log(pp.indexOf(&apos;a) &gt;&gt;&gt;&gt;&gt;&gt;-1)除此之外。对象const ee = &quot;gg&quot;pp=&#123;aa:66,cc:&apos;89&apos;&#125;pp[&apos;aa&apos;]&gt;&gt;&gt;&gt;66.pp[ee] = 100pp[&apos;gg&apos;]&gt;&gt;&gt;&gt;&gt;99数组：pp[0] = [].对于数组的话。 下标要为数字 overflow: auto 对于一些内容自适应高度的隐藏折叠非常好用。 点击隐藏和显示。overflow: scroll将隐藏所有溢出的内容并使滚动条出现在相关元素上。如果内容没有溢出，滚动条仍然可见，但被禁用。overflow: auto 非常相似，但滚动条仅在内容溢出时出现。 axios 的缺点（ajax,axios,fetch区别）1.JQ的ajax 12345678 $.ajax(&#123; type: &apos;POST&apos;, url: url, data: data, dataType: dataType, success: function () &#123;&#125;, error: function () &#123;&#125;&#125;); 优缺点：本身是针对MVC的编程,不符合现在前端MVVM的浪潮基于原生的XHR开发，XHR本身的架构不清晰，已经有了fetch的替代方案JQuery整个项目太大，单纯使用ajax却要引入整个JQuery非常的不合理（采取个性化打包的方案又不能享受CDN服务）优点的话：兼容IE的老版本。 axios1234567891011121314axios(&#123; method: &apos;post&apos;, url: &apos;/user/12345&apos;, data: &#123; firstName: &apos;Fred&apos;, lastName: &apos;Flintstone&apos; &#125;&#125;).then(function (response) &#123; console.log(response);&#125;).catch(function (error) &#123; console.log(error);&#125;); 优缺点：从 node.js 创建 http 请求支持 Promise API客户端支持防止CSRF提供了一些并发请求的接口（重要，方便了很多的操作） fetch1234567try &#123; let response = await fetch(url); let data = response.json(); console.log(data);&#125; catch(e) &#123; console.log(&quot;Oops, error&quot;, e);&#125; 优点：符合关注分离，没有将输入、输出和用事件来跟踪的状态混杂在一个对象里更好更方便的写法更加底层，提供的API丰富（request, response）脱离了XHR，是ES规范里新的实现方式缺点1）fetchtch只对网络请求报错，对400，500都当做成功的请求，需要封装去处理2）fetch默认不会带cookie，需要添加配置项3）fetch不支持abort，不支持超时控制，使用setTimeout及Promise.reject的实现的超时控制并不能阻止请求过程继续在后台运行，造成了量的浪费4）fetch没有办法原生监测请求的进度，而XHR可以 为什么要用axiosaxios 是一个基于Promise 用于浏览器和 nodejs 的 HTTP 客户端，它本身具有以下特征： 从浏览器中创建 XMLHttpRequest从 node.js 发出 http 请求支持 Promise API拦截请求和响应转换请求和响应数据取消请求动转换JSON数据客户端支持防止CSRF/XSRF（一些跨域浏览器的伪造请求） 比较安全 如果真的要说缺点他们浏览器支持有问题。 因为它只支持ie8+以上的。 老版本IE不支持 什么是跨域，以及解决跨域的实现方式有这样一个URL：http://item.taobao.com/item.htm?a=1&amp;b=2&amp;c=&amp;d=xxx&amp;e，请写一段JS程序提取URL中的各个GET参数(参数名和参数个数不确定)，将其按key-value形式返回到一个json结构中，如{a:&#39;1&#39;, b:’2’, c:’’, d:’xxx’, e:undefined}。一开始自己写的答案1234567891011121314function getKeyValue(url)&#123;const params=&#123;&#125;;if(url.indexOf(&apos;?&apos;)==-1) returnconst urlString = url.substring(url.indexOf(&apos;?&apos;)+1);urlString.split(&apos;&amp;&apos;).forEach((item)=&gt;&#123; if(item.indexOf(&apos;=&apos;)&gt;-1)&#123; let itemParams = item.split(&apos;=&apos;); params[itemParams[0]] = itemParams[1]&#125;else&#123; params[item] = &apos;underfined&apos;&#125;&#125;)return params&#125; 后面发现 其实split的话。 还是可以优化的。 因为就是就算split判断等号。获得一个数组。就算没有等号。 我赋值一个itemParams[1]。 不存在的话也会为underfined。12345678910function getKeyValue(url)&#123;const params=&#123;&#125;;if(url.indexOf(&apos;?&apos;)==-1) returnconst urlString = url.substring(url.indexOf(&apos;?&apos;)+1);urlString.split(&apos;&amp;&apos;).forEach((item)=&gt;&#123; let itemParams = item.split(&apos;=&apos;); params[itemParams[0]] = itemParams[1]&#125;)return params&#125; 升级版对于一些如果参数是同名的话。 把他们放在同一个数组里面12345678910111213141516function getMoreKeyValue(url)&#123; const params = &#123;&#125;;if(url.indexOf(&apos;?&apos;)==-1) returnconst urlString = url.substring(url.indexOf(&apos;?&apos;)+1);urlString.split(&apos;&amp;&apos;).forEach(item=&gt;&#123; let itemParams = item.split(&apos;=&apos;); if(params.hasOwnProperty(itemParams[0]))&#123; params[itemParams[0]]=Array.isArray(itemParams[0])?params[itemParams[0]].push(itemParams[1]) :[params[itemParams[0]],itemParams[1]]&#125;else&#123;params[itemParams[0]] = itemParams[1]&#125;&#125;)return params&#125;url = &apos;http://item.taobao.com/item.html?a=1&amp;b=2&amp;c=&amp;d=xxx&amp;e&amp;a=2&apos;;getMoreKeyValue(url) &gt;&gt;&gt;&gt;c &#123; a: [ &apos;1&apos;, &apos;2&apos; ], b: &apos;2&apos;, c: &apos;&apos;, d: &apos;xxx&apos;, e: undefined &#125; 经常问的红绿灯问题简单版本123456789101112131415161718192021setTimeout(changered,0); /*设置最开始时间间隔为0*/ function changered()&#123; var div=document.getElementById(&quot;div1&quot;); div.style.backgroundColor=&quot;red&quot;; console.log(&apos;红&apos;) setTimeout(changeyellow,7000);/*红灯持续亮7秒*/ &#125; function changeyellow()&#123; var div=document.getElementById(&quot;div1&quot;); div.style.backgroundColor=&quot;yellow&quot;; console.log(&apos;黄&apos;) setTimeout(changegreen,3000); &#125; function changegreen()&#123; console.log(&apos;绿&apos;) var div=document.getElementById(&quot;div1&quot;); div.style.backgroundColor=&quot;green&quot;; setTimeout(changered,5000); &#125; 对于一些需要要.then函数去做红绿等的方法12345678910111213141516171819//创建一个打印的函数function light(data)&#123; console.log(data)&#125;//封装一个setTimeout的函数function getSetTimeOut(time)&#123; return new Promise((resolve,reject)=&gt;&#123; setTimeout(()=&gt;&#123; resolve() &#125;,time) &#125;)&#125;//执行红绿灯函数async function begin()&#123;await getSetTimeOut(7000).then(console.log(&apos;红&apos;))await getSetTimeOut(5000).then(console.log(&apos;黄&apos;))await getSetTimeOut(3000).then(console.log(&apos;绿&apos;))begin()&#125; 两个数组做比较。 当有一个相等的话。 跳出循环。运行次数最少-自己项目的做法123456789101112131415161718192021222324252627282930array2 = [&apos;66&apos;,&apos;77,&apos;,&apos;99&apos;];array = [&apos;55&apos;,&apos;66&apos;,&apos;555&apos;,&apos;44&apos;];for(let i = 0;i&lt;array2.length;i++)&#123; bol = array.some(item=&gt;&#123; console.log(&apos;22&apos;); return item===array2[i]&#125;) if(bol) break;&#125;一个数字和数组做比较bol = array.some(item=&gt;&#123;console.log(22)return item===b&#125;)this.bankNbr = res.BANK_NBR; this.subBranchList = res.subBranchList; if (this.bankNbr != &apos;&apos;) &#123; this.isMatchSales = this.salesBranch.some(item =&gt; &#123; return item.brano === this.bankNbr; &#125;); &#125; else &#123; for (let i = 0; i &lt; this.subBranchList.length; i++) &#123; this.isMatchSales = this.salesBranch.some(item =&gt; &#123; return item.brano === this.subBranchList[i].subBranchNo; &#125;); if (this.isMatchSales) break; &#125; &#125; 减少对于for循环的使用。 用ES6的语法 find()。 取代for循环啊 find()。数组实例的方法。参数是一个回调函数。所有数组依次执行回调函数，直到找出一个返回值为true的成员。然后返回该成员。如果没有符合条件的成员，返回underfined.优化123const matchitem = this.subBranchList.find(sub =&gt;this.salesBranch.some(item =&gt; &#123;item.brano === usb.subBranchNo;&#125;););一行解决this.isMatchSales = !!matchitem //转义成boolean类型 !underfined =true !!=false 返回来item的话。就会这样Object.is(NAN,value) //查看数据类型为NAN的。 用find 用find的话 如果Item返回来是空字符类型的话，!!也会转化为false。 对于有空类型的话’’。用findIndex()比较好，返回来index索引.再去转boolean 比较好。对于find和findindex 当item返回来true的时候，都会跳出循环12const matchitem = this.subBranchList.findIndex(sub =&gt;this.salesBranch.some(item =&gt; &#123;item.brano === usb.subBranchNo;&#125;););一行解决this.isMatchSales = matchitem !==-1 //转义成boolean类型 findIndex相当于indexOf类似。 找不到的话， 会返回来索引-1 对于数组的相邻去重。 还有相邻相加- 同事出题123456789101112131415数组相邻去重bb = &apos;AAAAAAbbbbbbaaaaacccc&apos;bgg=[&apos;1&apos;,&apos;2&apos;,&apos;2&apos;,&apos;3&apos;,&apos;2&apos;] function getArray(params)&#123; const result = []; for(let i=0;i&lt;params.length;i++)&#123; if(i==0 ||params[i-1] !==params[i])&#123; result.push(params[i]) &#125; &#125; return result &#125;console.log(getArray(bb)) //[&quot;A&quot;, &quot;b&quot;, &quot;a&quot;, &quot;c&quot;]console.log(getArray(bgg)) //[&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;2&quot;] 123456789101112131415数组相邻相加bg=[&apos;1&apos;,&apos;4&apos;,&apos;4&apos;,&apos;4&apos;,&apos;2&apos;,&apos;3&apos;,&apos;3&apos;]function getArray2(params)&#123; const result = []; for(let i=0;i&lt;params.length;i++)&#123; if(params[i-1] !==params[i])&#123; result.push(params[i]) &#125;else if(params[i-1] ===params[i])&#123; const len = result.length; result[len-1] = (Number(result[len-1])+Number(params[i])).toString(); &#125; &#125; return result &#125;console.log(getArray2(bg)) //[&quot;1&quot;, &quot;12&quot;, &quot;2&quot;, &quot;6&quot;] bb=’aAbCdE’ 打印 “A-Aa-Bbb-Cccc-Ddddd-Eeeeee”123456789101112131415161718192021222324252627282930自己的思路function getArr2(strs)&#123;let allStr = &apos;&apos;; const creatDo = (case1,n)=&gt;&#123; let casestr1=&apos;&apos;; casestr1 = case1.toUpperCase()+case1.toLowerCase().repeat(n); return casestr1&#125;for(let j=0;j&lt;strs.length;j++)&#123;allStr = j==0?creatDo(strs[j],j):allStr+&apos;-&apos;+creatDo(strs[j],j);&#125;return allStr;&#125;ES7function func4(str) &#123; return str .split(&apos;&apos;) .map((en, i) =&gt; en.toUpperCase().padEnd(i + 1, en.toLowerCase())) //获得一个新数组。.padEnd(n,test) 代表在后面加N个test .join(&apos;-&apos;) //数组的并接&#125;ES6function fun5(str)&#123; return str .split(&apos;&apos;) .map((item,i)=&gt;`$&#123;item.toUpperCase()&#125;$&#123;item.toLowerCase().repeat(i)&#125;`) .join(&apos;-&apos;)&#125; 传入10 求出10里面（不包括10） 3 5 倍数相加之和 例如 3 6 9 5（3的倍数）（5的倍数） 3+6+9+5 = 23其实用循环是不可以的。所以啊 等差数列求和 等差求和算法 直接运算123456789function totol(nums)&#123; let sum=0; for(let i=0;i&lt;nums;i++)&#123; if(i%3==0||i%5==0)&#123; sum +=i; &#125; &#125; return sum;&#125; 1234567891011121314151617自己写的function totol(nums)&#123;let sum=0;let threeCount=1;let fiveCount=1; for(let i=3;i&lt;nums;i=3*threeCount)&#123; sum+=i; ++threeCount;console.log(threeCount) console.log(i) &#125;for(let j=5;j&lt;nums;j=5*fiveCount)&#123; sum+=j; fiveCount++;&#125;return sum&#125; 123456789优化后function fucc(num)&#123; let result = 0; for(let i=1;i*3&lt;num;i++)&#123; if(i*5&lt;num) result +=i*5 result +=i*3 &#125; return result;&#125; 判断回文数利用数组反序号123function isPalindrome(str)&#123; return str.split(&apos;&apos;).reverse().join(&apos;&apos;) ===str&#125;","categories":[],"tags":[]},{"title":"前端学习资料","slug":"前端学习资料","date":"2018-12-03T09:00:16.296Z","updated":"2018-12-11T09:19:14.660Z","comments":true,"path":"2018/12/03/前端学习资料/","link":"","permalink":"https://bolianglll.github.io/2018/12/03/前端学习资料/","excerpt":"","text":"作为一个前端攻城狮必须掌握的技能ES6阮一峰的ES6 是我觉的比较容易让人易懂和比较完善的教程。 http://es6.ruanyifeng.com/#docs/destructuring 代码规范化文章教程JSOC的规范化，是每一个攻城狮代码规范的标准。 值得学习 https://www.css88.com/doc/jsdoc/ HTTP跨域介绍-掘金的一篇好文推荐https://juejin.im/post/5a2f92c65188253e2470f16d#heading-5 前端面试题总结这是一个网上的团队总结的所有面试题。 我觉得这个文章不仅对我们面试有作用， 而且对于我们基础知识的提升也起很多作用。 值得我们去看看 https://yuchengkai.cn/docs/zh/frontend/ 个人学习介绍本人是主攻Web端的Vue攻城狮，我会在以后的日子里。慢慢的把我在实际项目中遇到的知识难点和亮点分享给各位热爱前端的同学。 哈哈哈， 我只是一个新手上路的菜鸟，如果看到我分享的只是有问题的话，很乐意你们去联系我。邮箱 - - - boliangleung@163.com希望我以后的东西能帮到大家","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2018-11-27T02:04:45.726Z","updated":"2018-12-03T08:12:49.829Z","comments":true,"path":"2018/11/27/hello-world/","link":"","permalink":"https://bolianglll.github.io/2018/11/27/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}