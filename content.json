{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"John Doe","url":"https://bolianglll.github.io"},"pages":[],"posts":[{"title":"关于CSS3中的 box-sizing border-box;","slug":"CSS3中的'' box-sizing border-box;'微妙之处","date":"2018-12-05T04:00:00.000Z","updated":"2018-12-05T09:29:14.481Z","comments":true,"path":"2018/12/05/CSS3中的'' box-sizing border-box;'微妙之处/","link":"","permalink":"https://bolianglll.github.io/2018/12/05/CSS3中的'' box-sizing border-box;'微妙之处/","excerpt":"","text":"在最近我在做自己的项目的过程之中， 在CSS中。我遇到了 box-sizing border-box;我通过用这个 box-sizing border-box;，简化了不少代码。 所以想在这通过网上的一些文章，和自己的一些理解来介绍一下 content-box指定元素的宽度和高度（最小/最大属性）适用于box的宽度和高度。元素的填充和边框布局和绘制指定宽度和高度除外 border-box指定宽度和高度（最小/最大属性）确定元素边框box。也就是说，对元素指定宽度和高度包括padding和border的指定。内容的宽度和高度减去各自双方该边框和填充的宽度从指定的”宽度”和”高度”属性计算 inherit指定box-sizing属性的值，应该从父元素继承 对于boder-box的计算方法border-box width 和 height 属性包括内容，内边距和边框，但不包括外边距。这是当文档处于 Quirks模式 时Internet Explorer使用的盒模型。注意，填充和边框将在盒子内 , 例如, .box {width: 350px; border: 10px solid black;} 导致在浏览器中呈现的宽度为350px的盒子。内容框不能为负，并且被分配到0，使得不可能使用border-box使元素消失。这里的维度计算为： width = border + padding + 内容的 width， height = border + padding + 内容的 height。 总结一般写页面对ui设计好的来说，我们最好使用这个属性，这样对整体布局很有好处，不然，页面很容易出现问题。 便于朋友记忆。 加多一个overflow:hidden的用法在此文章 overflow:hidden的作用是1.隐藏溢出的东西 #wai{ width:200px; background:#000; height:200px; border:2px blue solid; } #nei { float:left; width:300px; height:300px; background:red;} 当我们没有给wai这个div设置高度的时候，nei这个div的高度，就会撑开wai这个div，而在另一个方面，我们要注意到的是，当我们给wai这个div加上一个高度值，那么无论nei这个div的高度是多少，wai这个高度都是我们设定的值。而当nei的高度超过wai的高度的时候，超出的部分就会被隐藏。这就是隐藏溢出的含义!2.清楚浮动当nei这个div加上浮动这个属性的时候，在显示器的侧面，它已经脱离了wai这个div，也就是说，此时的nei的宽高是多少， 对于已经脱离了的wai来说，都是不起作用的。当我们全面的理解了浮动这个词的含义的时候，我们就理解overflow:hidden这个属性中的解释，清除浮动是什么意思了。也就是说，当我们给wai这个div加上overflow:hidden这个属性的时候，其中的nei等等带浮动属性的div的在这个立体的浮动已经被清除了。","categories":[],"tags":[]},{"title":"“实战项目用到的技术总结”","slug":"“实战项目技术总结”","date":"2018-12-04T02:19:41.000Z","updated":"2018-12-05T01:44:57.589Z","comments":true,"path":"2018/12/04/“实战项目技术总结”/","link":"","permalink":"https://bolianglll.github.io/2018/12/04/“实战项目技术总结”/","excerpt":"","text":"大概先总结一下后面会总结。请等待","categories":[],"tags":[]},{"title":"关于eventloop事件循环机制和aysnc和await的解决异步方法的详解","slug":"关于eventloop事件监听机制和aysnc和await的解决异步方法的详解","date":"2018-12-04T02:19:41.000Z","updated":"2018-12-05T03:36:06.566Z","comments":true,"path":"2018/12/04/关于eventloop事件监听机制和aysnc和await的解决异步方法的详解/","link":"","permalink":"https://bolianglll.github.io/2018/12/04/关于eventloop事件监听机制和aysnc和await的解决异步方法的详解/","excerpt":"","text":"此文章是我在朋友推荐给我看的文章，然后我自己想总结一下关于eventloop事件和aysnc和await的事件解决顺序（不讲解其中原理。讲顺序）。如果我讲解的有问题。 麻烦发我邮箱，嘻嘻嘻。 很高兴大家帮我指出错误。 此文章是参考下面两个博客文章的解释。 如果我讲解的不清楚，你们可以去该文章了解一下,我觉的他们解释的挺清楚和挺好的。https://www.cnblogs.com/hanzhecheng/p/9046144.html eventloophttps://juejin.im/post/5c0397186fb9a049b5068e54 async eventloop事件循环机制JavaScript的事件分两种，宏任务(macro-task)和微任务(micro-task) 宏任务：包括整体代码script，setTimeout，setInterval微任务：Promise.then(非new Promise)，process.nextTick(node中) 事件的执行顺序，是先执行宏任务，然后执行微任务，这个是基础，任务可以有同步任务和异步任务，同步的进入主线程，异步的进入Event Table并注册函数，异步事件完成后，会将回调函数放入Event Queue中(宏任务和微任务是不同的Event Queue)，同步任务执行完成后，会从Event Queue中读取事件放入主线程执行，回调函数中可能还会包含不同的任务，因此会循环执行上述操作。 JS是单线程语言也就是说，JS一次只能做一件事情。cpu处理指令速度非常快，远比磁盘I/O和网络I/O速度快，所以一些cpu直接执行的任务就成了优先执行主线任务（即同步任务synchronous），然后需要io返回数据的任务就成了等待被执行的任务（即异步任务asynchronous）同步任务：在主线程上排队执行的任务，前一个任务执行完毕，才能执行后一个任务；异步任务：不进入主线程、而进入”任务队列”（task queue）的任务，只有”任务队列”通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。 代码解析12345678910111213141516171819console.log('1');setTimeout(function() &#123; console.log('2'); process.nextTick(function() &#123; console.log('3'); &#125;) new Promise(function(resolve) &#123; console.log('4'); resolve(); &#125;).then(function() &#123; console.log('5') &#125;)&#125;)输出：12435 宏任务同步代码console.log(‘1’),不多说setTimeout，加入宏任务Event Queue，没有发现微任务，第一轮事件循环走完第二轮事件循环开始，先执行宏任务，从宏任务Event Queue中独取出setTimeout的回调函数同步代码console.log(‘2’),发现process.nextTick，加入微任务Event Queuenew Promise，同步执行console.log(‘4’),发现then，加入微任务Event Queue宏任务执行完毕，接下来执行微任务，先执行process.nextTick，然后执行Promise.then微任务执行完毕，第二轮事件循环走完，没有发现宏任务，事件循环结束 总结:1.事件循环，先执行宏任务，其中同步任务立即执行，异步任务，加载到对应的的Event Queue中(setTimeout等加入宏任务的Event Queue，Promise.then加入微任务的Event Queue)，2.所有同步宏任务执行完毕后，如果发现微任务的Event Queue中有未执行的任务，会先执行其中的任务，这样算是完成了一次事件循环。3.接下来查看宏任务的Event Queue中是否有未执行的任务，有的话，就开始第二轮事件循环，依此类推。记得上面的宏任务和微任务的分类。这个就是JS的eventloop的循环时间机制 ES6async和await的解决异步函数方法-事件顺序1.async介绍 async function 用于声明 一个 返回 AsyncFunction 对象的异步函数。异步函数是值通过事件循环异步执行的函数，它会通过一个隐式的 Promise 返回其结果。如果你的代码使用了异步函数，它的语法和结构更像是标准的同步函数也就是说每一个async都会返回来一个隐式的 Promise .如果还想了解更多关于async的内容，可以去上面分享的那个博主的网站去看。 我在下面想分析关于async的事件顺序机制。下面的解释不代表博主的说法错误。本人只是想通过eventloop的解释，去解释下面的顺序 async Promise setTimeout(定时器) 的结合使用情况求下面输出结果1234567891011121314151617181920async function async1()&#123; console.log('async1 start') await async2() console.log('async1 end')&#125;async function async2()&#123; console.log('async2')&#125;console.log('script start')setTimeout(function()&#123; console.log('setTimeout')&#125;,0) async1();new Promise(function(resolve)&#123; console.log('promise1') resolve();&#125;).then(function()&#123; console.log('promise2')&#125;)console.log('script end') 正确的答案是：script startasync1 startasync2promise1script endpromise2async1 endsetTimeou 非常重要的一句是：遇到 await 表达式时，会让 async 函数 暂停执行，等到 await 后面的语句（Promise）状态发生改变（resolved或者rejected）之后，再恢复 async 函数的执行（再之后 await 下面的语句），并返回解析值（Promise的值） 解释上面的顺序：1.执行同步任务-console.log(‘script start’) /12.遇到了宏任务，且为异步的setTimeout。 把次函数加入到宏任务的Event Queue3.执行async1（）里面的同步代码 console.log(‘async1 start’)/24.执行 async2()里面的同步代码 console.log(‘async2’) /3（但是async2函数是给async定义的一个函数。 他会返回来一个隐式的promise对象,而且也会跳出上面的async1函数）4.执行promise的同步代码 console.log(‘promise1’)/4。 遇到了promise().resolve(). 返回来了一个promise对象，。5.执行同步console.log(‘script end’)/5。第一轮事件走完第二轮时间开始6执行async2()中的promise()。要等待reslove()。 把他压进队列（）。7执行.then后面的函数 console.log(‘promise2’)/6.第三轮开始等待完async2的promise()之后。 执行 console.log(‘async1 end’) 可能大家还没多理解。 我一开始也是。 然后我测试多了几次后列如 1234567891011121314151617181920async function async1()&#123; console.log('async1 start') await async2() console.log('async1 end')&#125; function async2()&#123; console.log('async2')&#125;console.log('script start')setTimeout(function()&#123; console.log('setTimeout')&#125;,0) async1();new Promise(function(resolve)&#123; console.log('promise1') resolve();&#125;).then(function()&#123; console.log('promise2')&#125;)console.log('script end') 正确的答案是：script startasync1 startasync2promise1script endasync1 endpromise2setTimeou 解释上面的顺序：第一轮事件和上面的类似。 但是没有async2()没有给async封装。 不会返回来一个promose()对象。所以第二轮有问题第一轮事件走完第二轮时间开始6.执行 console.log(‘async1 end’)7执行.then后面的函数 console.log(‘promise2’)上面的顺序就会有变化了。 总结一下：除此之外。我在一些评论下看到： 宏任务的优先级，是高于微任务的啊，settimeout 是去了下一个event loop。而且我们可以把await后面的代码。都当promise.then（微任务），这样就非常的好理解了—其实看到这， 我就更清楚上面的顺序了。。 哈哈 ，–新手理解。 当压进队列后，会从一开始再运行一下。 其实上面我讲的可能有点混乱。 但是这可能是我自己一开始比较好理解的方法。然后一步一步看到别人的想法，才更容易理解。 如果讲的不够清楚。可以去上面的那些博客主里面看一看。欢迎大家给我意见。","categories":[],"tags":[]},{"title":"前端学习资料","slug":"前端学习资料","date":"2018-12-03T09:00:16.296Z","updated":"2018-12-03T09:30:29.212Z","comments":true,"path":"2018/12/03/前端学习资料/","link":"","permalink":"https://bolianglll.github.io/2018/12/03/前端学习资料/","excerpt":"","text":"作为一个前端攻城狮必须掌握的技能ES6阮一峰的ES6 是我觉的比较容易让人易懂和比较完善的教程。 http://es6.ruanyifeng.com/#docs/destructuring 代码规范化文章教程JSOC的规范化，是每一个攻城狮代码规范的标准。 值得学习 https://www.css88.com/doc/jsdoc/ 前端面试题总结这是一个网上的团队总结的所有面试题。 我觉得这个文章不仅对我们面试有作用， 而且对于我们基础知识的提升也起很多作用。 值得我们去看看 https://yuchengkai.cn/docs/zh/frontend/ 个人学习介绍本人是主攻Web端的Vue攻城狮，我会在以后的日子里。慢慢的把我在实际项目中遇到的知识难点和亮点分享给各位热爱前端的同学。 哈哈哈， 我只是一个新手上路的菜鸟，如果看到我分享的只是有问题的话，很乐意你们去联系我。邮箱 - - - boliangleung@163.com希望我以后的东西能帮到大家","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2018-11-27T02:04:45.726Z","updated":"2018-12-03T08:12:49.829Z","comments":true,"path":"2018/11/27/hello-world/","link":"","permalink":"https://bolianglll.github.io/2018/11/27/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}